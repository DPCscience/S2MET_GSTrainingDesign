---
title: "S2 MET Environmental Clustering and Prediction"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

## Introduction

This notebook covers prediction by clustering environments to reduce GxE and then perform predictions


```{r setup}

library(tidyverse)
library(stringr)
library(readxl)
library(neyhart)
library(rrBLUP)
library(gws)
library(pbr)
library(cluster)
library(purrrlyr)


# The head directory
proj_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET/"

fig_dir <- file.path(proj_dir, "Figures/")

# Prediction directory
pred_dir <- file.path(proj_dir, "Predictions")

# Other directories
geno_dir <-  "C:/Users/Jeff/Google Drive/Barley Lab/Projects/Genomic Selection/Genotypic Data/GBS Genotype Data/"
env_var_dir <- file.path(proj_dir, "Environmental_Variables/")
pheno_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET/Phenotype_Data/"
# Directory where entry data is located
entry_dir <- file.path(proj_dir, "Plant_Materials")


## Load Data
# Load the genotypic data
load(file.path(geno_dir, "S2_genos_mat.RData"))

# Load the phenotypic data
load(file.path(pheno_dir, "S2_MET_BLUE.RData"))
load(file.path(pheno_dir, "S2_MET_tidy.RData"))

# Load environmental data
load(file.path(env_var_dir, "environmental_data_compiled.RData"))

## Load the entry data
entry_list <- file.path(entry_dir, "S2MET_project_entries.xlsx") %>%
  read_excel()

# Separate into entries and checks
entries <- entry_list %>% 
  filter(Class %in% c("S2TP", "S2C1R"))

## Separate the TP and VP
tp <- entries %>%
  filter(Class == "S2TP") %>%
  pull(Line)

vp <- entries %>%
  filter(Class == "S2C1R") %>%
  pull(Line)

checks <- entry_list %>% 
    filter(Class == "Check") %>%
    pull(Line)

# Filter the BLUEs for the entries
S2_MET_BLUE_entries <- S2_MET_BLUE %>%
  filter(line_name %in% c(tp, vp))

S2_MET_tidy_use <- S2_MET_tidy %>%
  mutate_at(vars(line_name), as.character) %>%
  mutate(line = ifelse(!line_name %in% checks, line_name, "00check"),
         check = ifelse(line_name %in% checks, line_name, "00entry"),
         ge = interaction(line, environment))

```




### Clustering Methods

What is the point of clustering?
    + Prediction of single environments is difficult.
    + Clustering will take environments and group them into mega-environemnts of similar environments.
    + The idea is that environments should be clustered such that the GxE deviation within the mega-environment is minimized. Thus the mean of each line within each mega-environment is more representative of the genotypic value of that line in that mega-environment. Therefore the prediction accuracy of other lines in a new environment that is within that mega-environment will be more accurate.

I will look at four different distance methods:
    + Performance data on all lines in all environments
    + GxE deviation BLUPs from all environments (PCA)
    + Factor analysis to reduce cross-over interaction
    + Environmental covariates (via principal components)
    
The measure for performance data distance comes from the formula in @Bernardo2010 and the GxE BLUP deviation comes from @Beavis1996. These clustering methods may be better, since the use the observed phenotypes, however they do not allow a new environment to be predicted.

The fourth method will use environment data to cluster environments. As long as the environmental data explains some of the GxE, this method should be effective. It's greatest strength comes from the ability to predict new environments.


### Evaluating Cluster Effectiveness

If the GxE deviation is minimized within mega-environments, the heritability should improve. To compare clustering effectiveness, the heritability of selection within mega-environments will be compared to the base heritability and the heritability of selection across mega-environments

The base heritability will be calculated as:

$$
H = \frac{\sigma^2_g}
{\sigma^2_g + \frac{\sigma^2_{ge}}{n_e} + \frac{\sigma^2_\epsilon}{n_r n_e}},
$$

where $\sigma^2_g$ is the genetic variance, $\sigma^2_{ge}}$ is the GxE variance, $\sigma^2_\epsilon$ is the variance due to experimental error, $n_e$ is the number of environments and $n_r$ is the number of replications within environments.

The heritability of selection across mega-environments is

$$
H_a = \frac{\sigma^2_g}
{\sigma^2_g + \frac{\sigma^2_{gs}}{n_s} + \frac{\sigma^2_{ge(s)}}{n_e} + \frac{\sigma^2_\epsilon}{n_r n_e}},
$$

where $\sigma^2_{gs}$ is the variance due to genotype-by-megaenvironment interactions, $\sigma^2_{ge(s)}$ is the variance of GxE interactions nested within megaenvironments, and $n_s$ is the number of mega-environments.

The heritability of selection within mega-environments is

$$
H_w = \frac{\sigma^2_g + \sigma^2_{gs}}
{\sigma^2_g + \sigma^2_{gs} + n_s \bigg( \frac{\sigma^2_{ge(s)}}{n_e} + \frac{\sigma^2_\epsilon}{n_r n_e} \bigg)},
$$


## Methods

I will perform clustering first and then predictions later

### Clustering

Cluster first on all available data - including the validation set

Load the heritability results

```{r cluster.herit.load}

load_file <- file.path(proj_dir, "Predictions/Results/cluster_heritability.RData")
load(load_file)

# Combine the tp and all datasets
cluster_herit <- bind_rows(cluster_herit_all, cluster_herit_tp)




# Max clusters
max_K <- n_distinct(gauch_soy$env) - 1

# Use gap method to determine mega-environments
D2_cluster <- clusGap(x = as.matrix(D2), FUNcluster = hclusCut, 
                     K.max = max_K, B = 500, verbose = FALSE)

# Determine the optimal number of clusters by the "firstSEmax" method
opt_clust <- maxSE(D2_cluster$Tab[,"gap"], D2_cluster$Tab[,"SE.sim"], method = "firstSEmax", SE.factor = 1)



```

Load and plot results of the heritabilities

```{r cluster.herit}

load_file <- file.path(proj_dir, "Predictions/Results/cluster_heritability.RData")
load(load_file)

# Make some adjustments
herit_clust1 <- bind_rows(cluster_herit_all, cluster_herit_tp) %>% 
  unnest(out_df) %>% 
  mutate(method = str_replace_all(method, "_clust", ""), 
         method = parse_factor(method, levels = c("D", "FA", "PCA", "EC_one", "EC_multi")))

# Plot
(g_herit_clust <- herit_clust1 %>% 
    ggplot(aes(x = k, y = heritability, col = method, shape = selection)) + 
    geom_point() + 
    geom_line() + 
    facet_grid(population ~ trait) +
    labs(
      title = "Broad-Sense Heritability of Clustering Methods",
      subtitle = "'across' defines the heritability of selection across all mega-environments, and\n'within' defines the heritability of selection within mega-environments",
      caption ="D: clustering using Ouyang (1995) distance measure;\nFA: clustering using a factor analysis and 2 environmental loadings;\nPCA: clustering using the first 2 PCs of the GEI BLUPs;\nEC_one: clustering using the first 2 PCs of one-year environmental covariables;\nEC_multi: clustering using the first 2 PCs of the ten-year average of environmental covariables"
    ))
  
# Save it
save_file <- file.path(fig_dir, "cluster_heritability.jpg")
ggsave(filename = save_file, plot = g_herit_clust, width = 10, height = 10)


```


### Predictions

Using the clustering procedures from above, perform predictions among mega-environments

```{r cluster.pred}

# Load the data 
load_file <- file.path(proj_dir, "Predictions/Results/cluster_predictions.RData")
load(load_file)

## Pull out the no-cluster results
pred_acc_no_cluster <- pred_acc_results %>%
  unnest(acc) %>% 
  select(-`NA`) %>%
  mutate(method = str_replace_all(method, "_clust$", ""), 
         method = parse_factor(method, levels = c("D", "FA", "PCA", "EC_one", "EC_multi", "no_cluster")),
         pred_env = as.factor(pred_env),
         k = 1) %>%
  filter(method == "no_cluster")

pred_acc_results1 <- pred_acc_results %>% 
  unnest(acc) %>% 
  select(-`NA`) %>%
  mutate(method = str_replace_all(method, "_clust$", ""), 
         method = parse_factor(method, levels = c("D", "FA", "PCA", "EC_one", "EC_multi", "no_cluster")),
         pred_env = as.factor(pred_env)) %>%
  complete(trait, method, pred_env, population, k) %>%
  filter(method != "no_cluster")

# How many environments have no predictions?
n_blank_env <- pred_acc_results1 %>% 
  group_by(pred_env) %>% 
  summarize(p_na = mean(is.na(r_hat))) %>%
  filter(p_na == 1) %>%
  nrow()


# Join the cluster-based and non cluster-based results
pred_acc_comparison <- pred_acc_results1 %>%
  filter(k == 5) %>%
  full_join(., select(pred_acc_no_cluster, trait, pred_env:CI_upper), by = c("trait", "pred_env")) %>%
  # Is the cluster accuracy better than the non-cluster accuracy?
  mutate(cluster_better = r_hat.x >= r_hat.y,
         cluster_worse = r_hat.x < r_hat.y,
         cluster_sig_better = r_hat.x > CI_upper.y,
         cluster_sig_worse = r_hat.x < CI_lower.y)

# How often is some form of clustering better than not clustering?
pred_acc_comparison %>%
  group_by(trait, population, pred_env) %>%
  summarize(n_better = sum(cluster_better, na.rm = T),
            n_worse = sum(cluster_worse, na.rm = T),
            n_sig_better = sum(cluster_sig_better, na.rm = T),
            n_sig_worse = sum(cluster_sig_worse, na.rm = T)) %>%
  group_by(trait, population) %>%
  summarize(prop_one_better = mean(n_better >= 1),
            prop_all_worse = mean(n_better == 0),
            prop_one_sig_better = mean(n_sig_better >= 1))

# How often are different forms of clustering better than not clustering?
pred_acc_comparison_by_method <- pred_acc_comparison %>%
  group_by(trait, population, method) %>%
  summarize(prop_better = mean(cluster_better, na.rm = T),
            prop_worse = mean(cluster_worse, na.rm = T),
            prop_sig_better = mean(cluster_sig_better, na.rm = T),
            prop_sig_worse = mean(cluster_sig_worse, na.rm = T))

# Plot
(g_pred_acc_comp <- pred_acc_comparison_by_method %>%
    gather(metric, value, -trait:-method) %>%
    mutate(metric = parse_factor(metric, levels = c("prop_sig_better", "prop_better",
                                                    "prop_worse", "prop_sig_worse"))) %>%
    ggplot(aes(x = metric, y = value, fill = method)) +
    geom_col(position = "dodge") +
    facet_grid(trait ~ population) +
    ylim(c(0,1)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      title = "Proportion of Superior/Inferior Clustering",
      subtitle = "Proportion of observations in which the clustering method is superior or inferior to not clustering."
  ))

save_file <- file.path(fig_dir, "cluster_method_comparison.jpg")
ggsave(filename = save_file, plot = g_pred_acc_comp, width = 8, height = 6)
            

```


For each of $k \in \{3, ..., 6\}$, plot the comparison among clustering methods and non-clustering

```{r plot.k}

# Iterate over 
Kset <- unique(pred_acc_results_plot$k)

for (K in Kset) {
  
  # Plot the accuracy to predict each environment under different clustering procedures
  (g_pred_clust_all <- pred_acc_results1 %>%
     filter(population != "tp", k == K) %>%
     # Add the no-cluster data
     bind_rows(., pred_acc_no_cluster) %>%
     # Filter completely blank envs
     group_by(pred_env) %>%
     filter(mean(is.na(r_hat)) < 1) %>%
     ggplot(aes(x = pred_env, y = r_hat, group = method, fill = method)) + 
     labs(
       title = "Prediction Accuracy Within Clusters",
       subtitle = str_c("Compared prediction accuracy of each environment under k = ", K, " clusters determined by all entries or without clustering"),
       caption = str_c("D: clustering using Ouyang (1995) distance measure;\nFA: clustering using a factor analysis and 2 environmental loadings;\nPCA: clustering using the first 2 PCs of the GEI BLUPs;\nEC_one: clustering using the first 2 PCs of one-year environmental covariables;\nEC_multi: clustering using the first 2 PCs of the ten-year average of environmental covariables\nNote: ", n_blank_env, " environments were removed because predictions could not be made.")
     ) +
     geom_col(position = "dodge") + 
     geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper, group = method), position = "dodge") +
     facet_grid(trait ~ .) +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
     theme_bw() +
     ylim(c(-0.75, 1)))
  
  # Save it
  save_file <- file.path(fig_dir, str_c("cluster_k", K, "_predictions_all.jpg"))
  ggsave(filename = save_file, plot = g_pred_clust_all, width = 12, height = 8)

  (g_pred_clust_tp <- pred_acc_results1 %>% 
    filter(population != "all", k == K) %>%
    # Add the no-cluster data
    bind_rows(., pred_acc_no_cluster) %>%
    # Filter completely blank envs
    group_by(pred_env) %>%
    filter(mean(is.na(r_hat)) < 1) %>%
    ggplot(aes(x = pred_env, y = r_hat, group = method, fill = method)) + 
    labs(
      title = "Prediction Accuracy Within Clusters",
      subtitle = str_c("Compared prediction accuracy of each environment under k = ", K, " clusters determined by training population entries or without clustering"),
      caption = str_c("D: clustering using Ouyang (1995) distance measure;\nFA: clustering using a factor analysis and 2 environmental loadings;\nPCA: clustering using the first 2 PCs of the GEI BLUPs;\nEC_one: clustering using the first 2 PCs of one-year environmental covariables;\nEC_multi: clustering using the first 2 PCs of the ten-year average of environmental covariables\nNote: ", n_blank_env, " environments were removed because predictions could not be made.")
    ) +
     geom_col(position = "dodge") + 
     geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper, group = method), position = "dodge") +
     facet_grid(trait ~ .) +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
     theme_bw() +
     ylim(c(-0.75, 1)))            

  # Save it
  save_file <- file.path(fig_dir, str_c("cluster_k", K, "_predictions_tp.jpg"))
  ggsave(filename = save_file, plot = g_pred_clust_tp, width = 12, height = 8)
  
}



```


It appears that the effect of clustering on the accuracy to predict each environment is highly dependent on the environment itself. Clustering seems to help in some cases - it is worth exploring the conditions under which prediction accuracy is improved for an environmen (compared to not clustering).

Hypothesis: the heritability 




For each of the clustering methods, plot the comparison among k clusters versus no clustering


```{r plot.methods}

# Iterate over 
methods_set <- unique(pred_acc_results_plot$method)

for (met in methods_set) {
  
  # Plot the accuracy to predict each environment under different clustering procedures
  (g_pred_clust_all <- pred_acc_results1 %>%
     filter(population != "tp", method == met) %>%
     # Add the no-cluster data
     bind_rows(., pred_acc_no_cluster) %>%
     mutate(k = as.factor(k)) %>%
     # Filter completely blank envs
     group_by(pred_env) %>%
     filter(mean(is.na(r_hat)) < 1) %>%
     ggplot(aes(x = pred_env, y = r_hat, group = k, fill = k)) + 
     labs(
       title = "Prediction Accuracy Within Clusters",
       subtitle = str_c("Compared prediction accuracy of each environment under method: ", met, " clusters determined by all entries or without clustering"),
       caption = str_c("Note: ", n_blank_env, " environments were removed because predictions could not be made.")
     ) +
     geom_col(position = "dodge") + 
     geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper, group = k), position = "dodge") +
     facet_grid(trait ~ .) +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
     theme_bw() +
     ylim(c(-0.75, 1)) +
     scale_fill_brewer(type = "qual", palette = "Accent"))
  
  # Save it
  save_file <- file.path(fig_dir, str_c("cluster_met", met, "_predictions_all.jpg"))
  ggsave(filename = save_file, plot = g_pred_clust_all, width = 12, height = 8)

  (g_pred_clust_tp <- pred_acc_results1 %>% 
    filter(population != "all", method == met) %>%
    # Add the no-cluster data
    mutate(k = as.factor(k)) %>%
    # Filter completely blank envs
    group_by(pred_env) %>%
    filter(mean(is.na(r_hat)) < 1) %>%
    ggplot(aes(x = pred_env, y = r_hat, group = k, fill = k)) + 
    labs(
      title = "Prediction Accuracy Within Clusters",
      subtitle = str_c("Compared prediction accuracy of each environment under method: ", met, " clusters determined by training population entries or without clustering"),
      caption = str_c("Note: ", n_blank_env, " environments were removed because predictions could not be made.")
    ) +
     geom_col(position = "dodge") + 
     geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper, group = k), position = "dodge") +
     facet_grid(trait ~ .) +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
     theme_bw() +
     ylim(c(-0.75, 1)) +
     scale_fill_brewer(type = "qual", palette = "Accent"))

  # Save it
  save_file <- file.path(fig_dir, str_c("cluster_met", met, "_predictions_tp.jpg"))
  ggsave(filename = save_file, plot = g_pred_clust_tp, width = 12, height = 8)
  
}



```


Model differences among prediction accuracy


```{r cluster.mod}

# Analyze the two populations and traits separately
cluster_mod <- pred_acc_results1 %>% 
  group_by(population, trait) %>% 
  filter(k == as.factor(k)) %>%
  do(mod = lm(r_hat ~ method + pred_env + k + method:pred_env, data = .)) %>%
  mutate(summary = list(summary(mod)),
         anova = list(anova(mod)))

# Check which terms are significant
cluster_sig <- cluster_mod %>%
  mutate(anova = list(broom::tidy(anova))) %>%
  unnest(anova) %>%
  filter(term != "Residuals") %>% 
  group_by(term) %>% 
  summarize(prop_sig = mean(p.value < 0.05))

## Run Tukey's to get significant method and method:pred_env comparisons
cluster_tukeys <- cluster_mod %>% 
  mutate(tukeys_method = list(TukeyHSD(aov(mod), which = "method")),
         tukeys_method_tidy = list(broom::tidy(tukeys_method)))
  
# Significant method comparisons
cluster_tukeys %>% 
  unnest(tukeys_method_tidy) %>% 
  filter(adj.p.value < 0.05)



```





## Appendix

### Cluster Testing

Use the gauch_soy dataset to test these procedures

```{r app.setup}

# Find balanced environments
gauch_soy <- gauch.soy %>% 
  modify_if(is.factor, as.character) %>%
  group_by(env, gen) %>% 
  filter(n_distinct(rep) == 4) %>%
  group_by(env) %>%
  filter(n_distinct(gen) == 7) %>%
  ungroup() %>%
  mutate(ge = interaction(gen, env, sep = ":"))

```



#### Method 1 - Distance and Gap Method

```{r D}
# Fit a model for the base heritability
base_mod <- lmer(yield ~ (1|gen) + env + (1|gen:env) + (1|env:rep), data = gauch_soy)

# Calculate the base heritability
herit_base <- base_herit(mod = base_mod)




# Find the pairwise environmental distances
D <- dist_env(x = gauch_soy)

# Max clusters
max_K <- n_distinct(gauch_soy$env) - 1

# Use gap method to determine mega-environments
D_cluster <- clusGap(x = as.matrix(D), FUNcluster = hclusCut, 
                     K.max = max_K, B = 500, verbose = FALSE)

# Determine the optimal number of clusters by the "firstSEmax" method
opt_clust <- maxSE(D_cluster$Tab[,"gap"], D_cluster$Tab[,"SE.sim"], method = "firstSEmax", SE.factor = 1)

# Cluster and cut the tree
clusters <- hclusCut(x = D, k = 2)$cluster %>%
  data_frame(env = names(.), cluster = .)

# Assign clusters to the dataset
gauch_soy_clust <- gauch_soy %>%
  full_join(., clusters, "env") %>%
  mutate(cluster = as.factor(cluster))


# Fit a new model with clusters
clust_mod <- lmer(yield ~ (1|gen) + env + (1|env:rep) + (1|gen:env) + (1|gen:env:cluster), 
                  data = gauch_soy_clust)

# Heritability
(herit_clust <- clust_herit(clust_mod))

# Combine
herit <- add_row(herit_clust, selection = "base", heritability = herit_base)



```


Attempt here an iterative procedure where clusters are formed based on the heritability of selection within the clusters

```{r clust.iter}

# Max clusters
max_K <- n_distinct(gauch_soy$env) - 1

# Build a data.frame
cluster_out <- data_frame(k = seq(max_K))

# Iterate over clusters
cluster_herit <- cluster_out %>%
  by_row(function(line) {
    
    # Cluster and cut the tree
    clusters <- hclusCut(x = D, k = line$k)$cluster %>%
      data_frame(env = names(.), cluster = .)

    # Assign clusters to the dataset
    gauch_soy_clust <- left_join(gauch_soy, clusters, "env") %>%
      mutate(cluster = as.factor(cluster))


    # Fit a new model with clusters
    clust_mod <- lmer(yield ~ (1|gen) + env + (1|env:rep) + (1|gen:env) + (1|gen:env:cluster), 
                      data = gauch_soy_clust)
    
    clust_herit(clust_mod) }, .to = "out_df")


# Plot
cluster_herit %>%
  unnest() %>%
  ggplot(aes(x = k, y = heritability, group = selection, col = selection)) +
  geom_point() +
  geom_line()



```


#### Method 2 - PCA of GxE BLUP effects

```{r gxe.blup.pca}

# GxE term
ge_term <- "ge"

# Re-fit the base model
base_mod <- lmer(yield ~ (1|gen) + env + (1|ge) + (1|env:rep), data = gauch_soy)

# Get the interaction blups and form a matrix
ge_effect <- ranef(base_mod)[[ge_term]] %>%
  rownames_to_column("grp") %>%
  separate(grp, c("gen", "env")) %>%
  rename(effect = `(Intercept)`) %>%
  spread(env, effect) %>% 
  remove_rownames() %>% 
  column_to_rownames("gen") %>% 
  as.matrix()

# Run PCA
ge_svd <- prcomp(ge_effect)

# Variance explained by first two PCs
(ge_svd$sdev / sum(ge_svd$sdev))[1:2] %>%
  structure(names = c("PC1", "PC2"))

# Plot
plot(ge_svd$rotation)

# Calculate a distance using first two PCs
D2 <- dist(ge_svd$rotation[,1:2])

plot(hclust(D2, method = "average"))


## Iterate over k = 1, 2, ..., K clusters and calculate within and between H

# Max clusters
max_K <- n_distinct(gauch_soy$env) - 1

# Use gap method to determine mega-environments
D2_cluster <- clusGap(x = as.matrix(D2), FUNcluster = hclusCut, 
                     K.max = max_K, B = 500, verbose = FALSE)

# Determine the optimal number of clusters by the "firstSEmax" method
opt_clust <- maxSE(D2_cluster$Tab[,"gap"], D2_cluster$Tab[,"SE.sim"], method = "firstSEmax", SE.factor = 1)

# Build a data.frame
cluster_out <- data_frame(k = seq(max_K))

# Iterate over clusters
cluster_herit <- cluster_out %>%
  by_row(function(line) {
    
    # Cluster and cut the tree
    clusters <- hclusCut(x = D2, k = line$k)$cluster %>%
      data_frame(env = names(.), cluster = .)

    # Assign clusters to the dataset
    gauch_soy_clust <- left_join(gauch_soy, clusters, "env") %>%
      mutate(cluster = as.factor(cluster))


    # Fit a new model with clusters
    clust_mod <- lmer(yield ~ (1|gen) + env + (1|env:rep) + (1|gen:env) + (1|gen:env:cluster), 
                      data = gauch_soy_clust)
    
    clust_herit(clust_mod) }, .to = "out_df")


# Plot
cluster_herit %>%
  unnest() %>%
  ggplot(aes(x = k, y = heritability, group = selection, col = selection)) +
  geom_point() +
  geom_line() + 
  geom_vline(xintercept = opt_clust)
  


```


#### Method 3 - Factor Analysis

The factor analysis is performed on the random effect of the *i*th genotype in the *j*th environment

```{r factor.analysis}

library(psych)

# Response of genotype in environment
gauch_soy_geno_mean_df <- gauch_soy %>% 
  group_by(gen, env) %>% 
  summarize(mean = mean(yield)) %>%
  mutate(ge = interaction(gen, env))

gauch_soy_geno_mean <- gauch_soy_geno_mean_df%>% 
  spread(env, mean) %>% 
  as.data.frame() %>% 
  remove_rownames() %>% 
  column_to_rownames("gen") %>%
  scale() %>%
  as.data.frame()

fa2 <- fa(r = gauch_soy_geno_mean, nfactors = 2, rotate = "varimax")

# Get the loadings and residuals
delta <- fa2$loadings
psi <- diag(fa2$uniquenesses)

# Estimate of the correlation matrix
sigma <- tcrossprod(delta) + psi

# Identity matrix for the relationship between genotypes
A <- diag(n_distinct(gauch_soy$gen)) %>%
  structure(dimnames = list(unique(gauch_soy$gen), unique(gauch_soy$gen)))

G <- kronecker(sigma, A, make.dimnames = TRUE) 

# Model frame
mf <- model.frame(formula = mean ~ gen + env + ge, data = gauch_soy_geno_mean_df)

y <- model.response(mf)
X <- model.matrix(~ env, data = mf)
Zlist <- model.matrix(~ ge, data = mf)

fa_fit <- mixed.solve(y = y, X = X, Z = Zlist$ge$Z, K = G)

# Cluster using the environmental loadings
delta_dist <- hclust(dist(delta), method = "average")
max_K <- length(delta_dist$labels) - 1

# Iterate over cluster numbers
# Assign clusters
# Refit the FA model using clusters instead of environments
# Find the loadings and apply to all environments in the cluster
cluster_out <- data_frame(k = seq(max_K, 1))

# Iterate over clusters
cluster_herit <- cluster_out %>%
  by_row(function(line) {
    
    # Cut the tree
    clusters <- cutree(delta_dist, k = line$k) %>%
      data_frame(env = names(.), cluster = .) %>%
      mutate(cluster = str_c("C", cluster))
    
    gauch_soy_geno_mean_df <- gauch_soy %>% 
      left_join(., clusters, "env") %>%
      group_by(gen, cluster) %>% 
      mutate(mean = mean(yield)) %>%
      distinct(gen, env, cluster, mean)

    gauch_soy_geno_mean <- gauch_soy_geno_mean_df %>% 
      distinct(gen, cluster, mean) %>%
      spread(cluster, mean) %>% 
      as.data.frame() %>% 
      remove_rownames() %>% 
      column_to_rownames("gen") %>%
      scale() %>%
      as.data.frame()

    fa2 <- fa(r = gauch_soy_geno_mean, nfactors = 2, rotate = "varimax")

    # Get the loadings and residuals
    delta <- fa2$loadings
    psi <- fa2$uniquenesses %>%
      data_frame(cluster = names(.), psi = .)
    
    # Convert loadings to data frame and merge
    delta_df <- structure(delta, class = "matrix") %>% 
      as.data.frame() %>% 
      rownames_to_column("cluster") 
    
    # Merge
    cluster_att_merge <- list(gauch_soy_geno_mean_df, delta_df, psi) %>% 
      reduce(left_join, "cluster") %>%
      ungroup() %>% 
      distinct(env, MR1, MR2, psi) %>% 
      as.data.frame() %>%
      column_to_rownames("env") %>% 
      as.matrix()
    
    delta_mat <- cluster_att_merge[,c("MR1", "MR2")]
    psi_mat <- cluster_att_merge[,"psi"]
    
    sigma <- tcrossprod(delta_mat) + diag(psi_mat)
    
    # New covariance matrix
    G <- kronecker(sigma, A, make.dimnames = TRUE) 

    # Solve
    fa_fit <- mixed.solve(y = y, X = X, Z = Zlist, K = G)
    
    # Assign clusters to the dataset
    gauch_soy_clust <- left_join(gauch_soy, clusters, "env") %>%
      mutate(cluster = as.factor(cluster))


    # Fit a new model with clusters
    clust_mod <- lmer(yield ~ (1|gen) + env + (1|env:rep) + (1|gen:env) + (1|gen:env:cluster), 
                      data = gauch_soy_clust)
    
    clust_herit(clust_mod) }, .to = "out_df")



# Fit full model
mixed.solve()
fa_fit <-

```

