---
title: "S2 MET Environmental Clustering and Prediction"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

## Introduction

This notebook covers prediction by clustering environments to reduce GxE and then perform predictions


```{r setup}

library(tidyverse)
library(stringr)
library(readxl)
library(neyhart)
library(rrBLUP)
library(gws)
library(pbr)
library(purrrlyr)
library(ggridges)
library(ggforce)

# The head directory
proj_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET/"

source(file.path(proj_dir, "source.R"))

```




### Clustering Methods

What is the point of clustering?
    + Prediction of single environments is difficult.
    + Clustering will take environments and group them into mega-environemnts of similar environments.
    + The idea is that environments should be clustered such that the GxE deviation within the mega-environment is minimized. Thus the mean of each line within each mega-environment is more representative of the genotypic value of that line in that mega-environment. Therefore the prediction accuracy of other lines in a new environment that is within that mega-environment will be more accurate.

I will look at four different distance methods:
    + Performance data on all lines in all environments
    + GxE deviation BLUPs from all environments (PCA)
    + Factor analysis to reduce cross-over interaction
    + Environmental covariates (via principal components)
    
The measure for performance data distance comes from the formula in @Bernardo2010 and the GxE BLUP deviation comes from @Beavis1996. These clustering methods may be better, since the use the observed phenotypes, however they do not allow a new environment to be predicted.

The fourth method will use environment data to cluster environments. As long as the environmental data explains some of the GxE, this method should be effective. It's greatest strength comes from the ability to predict new environments.


### Evaluating Cluster Effectiveness

If the GxE deviation is minimized within mega-environments, the heritability should improve. To compare clustering effectiveness, the heritability of selection within mega-environments will be compared to the base heritability and the heritability of selection across mega-environments

The base heritability will be calculated as:

$$
H = \frac{\sigma^2_g}
{\sigma^2_g + \frac{\sigma^2_{ge}}{n_e} + \frac{\sigma^2_\epsilon}{n_r n_e}},
$$

where $\sigma^2_g$ is the genetic variance, $\sigma^2_{ge}}$ is the GxE variance, $\sigma^2_\epsilon$ is the variance due to experimental error, $n_e$ is the number of environments and $n_r$ is the number of replications within environments.

The heritability of selection across mega-environments is

$$
H_a = \frac{\sigma^2_g}
{\sigma^2_g + \frac{\sigma^2_{gs}}{n_s} + \frac{\sigma^2_{ge(s)}}{n_e} + \frac{\sigma^2_\epsilon}{n_r n_e}},
$$

where $\sigma^2_{gs}$ is the variance due to genotype-by-megaenvironment interactions, $\sigma^2_{ge(s)}$ is the variance of GxE interactions nested within megaenvironments, and $n_s$ is the number of mega-environments.

The heritability of selection within mega-environments is

$$
H_w = \frac{\sigma^2_g + \sigma^2_{gs}}
{\sigma^2_g + \sigma^2_{gs} + n_s \bigg( \frac{\sigma^2_{ge(s)}}{n_e} + \frac{\sigma^2_\epsilon}{n_r n_e} \bigg)},
$$


## Methods

I will perform clustering first and then predictions later

### Clustering

What do the different clustering strategies look like?

```{r}
# Load the distance data
load(file.path(result_dir, "S2_MET_cluster_df.RData"))

# Use multi-dimentional scaling on all of the distance matrices
# First create a mapping function
map_cmdscale <- function(x) {
  map(x, function(x) 
    cmdscale(x, k = 2) %>% 
      as.data.frame() %>% 
      rownames_to_column("environment") %>% 
      rename_at(vars(V1, V2), str_replace_all, "V", "PCo")) }

mds_method <- clust_method_df %>% 
  select(trait, D, PCA, FA, EC_one_dist, EC_multi_dist) %>%
  group_by(trait) %>%
  summarize_all(funs(map_cmdscale)) %>%
  gather(method, data, -trait) %>% 
  mutate(method = parse_factor(method, levels = c("D", "FA", "PCA", "EC_one_dist", "EC_multi_dist"))) %>%
  unnest() %>%
  # Assign years to environments
  mutate(year = str_c("20", str_extract(environment, "[0-9]{2}$"))) %>%
  # Find outlier environments
  group_by(trait, method) %>%
  mutate(meanPCo1 = mean(PCo1), meanPCo2 = mean(PCo2),
         sdPCo1 = sd(PCo1), sdPCo2 = sd(PCo2),
         outlierPCo1 = PCo1 > meanPCo1 + (2 * sdPCo1) | PCo1 < meanPCo1 - (2 * sdPCo1),
         outlierPCo2 = PCo2 > meanPCo2 + (2 * sdPCo1) | PCo2 < meanPCo2 - (2 * sdPCo1),
         outlier = ifelse(outlierPCo1 | outlierPCo2, environment, ""))

# Normal plot with facet_wrap
(g_clust_spat <- mds_method %>%
  ggplot(aes(x = PCo1, y = PCo2, col = year)) +
  geom_point() + 
  geom_text(aes(label = outlier), size = 2, hjust = "inward", vjust = "inward") +
  facet_wrap(trait ~ method, scales = "free", ncol = 5) +
  scale_color_discrete(guide = guide_legend(title = "Year")) +
  theme_bw() +
  theme(
    axis.text = element_blank(),
  ) +
  labs(
    title = "Spatial Relationship of Environments",
    subtitle = "Environmental relationships defined by 5 different distance methods.",
    caption = "Note: scales are different for each distance method and trait. The 'EC' methods are identical across traits."
  ))

save_file <- file.path(fig_dir, "env_spatial_rel.jpg")
ggsave(filename = save_file, plot = g_clust_spat, width = 8, height = 6)


```


Cluster first on all available data - including the validation set

Load and plot results of the heritabilities

```{r cluster.herit}

load(file.path(result_dir, "S2_MET_cluster_heritability.RData"))

# Convert some variables
cluster_herit_all_use <- cluster_herit_all %>% 
  bind_rows() %>%
  ungroup() %>%
  mutate(k = as.factor(k),
         method = parse_factor(method, levels = c("D", "FA", "PCA", "EC_one_dist", "EC_multi_dist")))

#Extract heritability results and plot
cluster_herit_all1 <- cluster_herit_all_use %>% 
  ungroup() %>% 
  select(-fit_summ) %>% 
  gather(herit_type, value, -trait:-k) %>%
  mutate(k = parse_number(k))

# Plot
(g_herit_clust <- cluster_herit_all1 %>% 
    ggplot(aes(x = k, y = value, col = method, shape = herit_type)) + 
    geom_point() + 
    geom_line() + 
    facet_grid(. ~ trait) +
    labs(
      title = "Broad-Sense Heritability of Clustering Methods",
      subtitle = "'across' defines the heritability of selection across all mega-environments, and\n'within' defines the heritability of selection within mega-environments",
      caption ="D: clustering using Ouyang (1995) distance measure;\nFA: clustering using a factor analysis and 2 environmental loadings;\nPCA: clustering using the first 2 PCs of the GEI BLUPs;\nEC_one: clustering using the first 2 PCs of one-year environmental covariables;\nEC_multi: clustering using the first 2 PCs of the ten-year average of environmental covariables"
    ) +
  theme_bw())
  
# Save it
save_file <- file.path(fig_dir, "cluster_heritability.jpg")
ggsave(filename = save_file, plot = g_herit_clust, width = 8, height = 5)


```


How does clutering impact the contribution of $sigma^2_g$ and $sigma^2_gc$ to total genetic variance? When does $sigma^2_gs$ become non-significant?

```{r lrt.gxs}

# Convert LR to numeric and conduct the LRT
cluster_lrt <- cluster_herit_all_use %>% 
  unnest(fit_summ) %>% 
  select(-var_comp) %>%
  mutate(llik = map_dbl(llik, as.numeric)) %>%
  group_by(trait, method, k) %>%
  mutate(lr = (-2 * (llik - llik[1])),
         lr = ifelse(mod == "full", NA, lr),
         p_value = pchisq(q = lr, df = 1, lower.tail = FALSE) / 2)

# Get the significance results for gc
gc_lrt <- cluster_lrt %>% 
  filter(mod == "no_gc") %>% 
  mutate(mod = "line_name:cluster") %>% 
  select(trait:k, grp = mod, p_value)
  
# Extract variance components
cluster_varcomp <- cluster_herit_all_use %>% 
  unnest(fit_summ) %>% 
  unnest(var_comp) %>% 
  filter(mod == "full", 
         grp != "Residual") %>% 
  select(trait:grp, vcov)

# What is the range in cluster k?
# k_range <- 


# Plot G and GxS sd over methods and k
(g_cluster_varcomp <- full_join(cluster_varcomp, gc_lrt, by = c("trait", "method", "k", "grp")) %>% 
  filter(grp %in% c("line_name", "gc")) %>%
  mutate(grp = parse_factor(grp, levels = c("line_name", "gc")),
         sig = ifelse(p_value < 0.001, "***", 
                      ifelse(p_value < 0.01, "**", ifelse(p_value < 0.05, "*", "")))) %>% 
  # Find the proportion of the usable genetic variance explained by g or gc
  group_by(trait, method, k) %>% 
  mutate(prop_var = vcov / sum(vcov, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(k = parse_number(k)) %>%
  ggplot(aes(x = k, y = prop_var, fill = method, alpha = grp, group = method)) +
  geom_col(position = "stack", col = "black") + 
  # geom_label(aes(y = 0.5, label = sig, angle = 90)) +
  facet_grid(trait ~ method) +
  scale_alpha_manual(values = c(1, 0.3), guide = guide_legend(title = "Variance Component")) +
  scale_fill_discrete(guide = guide_legend(title = "Method")) +
  ylab("Proportion of Usable Variance") +
  xlab("Number of Clusters") +
  labs(
    title = "Contributions to Usable Genetic Variance",
    subtitle = expression('Relative proportions of'~sigma[g]^2~'and'~sigma[gs]^2~'to the usable genetic variance')
  ) +
  theme_bw())

# Save it
save_file <- file.path(fig_dir, "cluster_usable_gen_var.jpg")
ggsave(filename = save_file, plot = g_cluster_varcomp, width = 8, height = 6)


```



### Predictions

#### Add More Distant Enviroments

Using the distance metrics above, start with each prediction environment and add increasingly more distant environments. Fit the model (assuming homogeneity of genetic variance) and assess prediction accuracy.


```{r}

# Load the data
load(file.path(result_dir, "S2MET_pred_by_env_dist.RData"))

# Remove missing
add_one_env_pred1 <- add_one_env_pred %>%
  # .[!map_lgl(., inherits, "try-error")] %>% 
  bind_rows() %>%
  unnest() %>% 
  select(-trait1:-core)

## Remove observations in which the number of environments is greater than the
## minimum for any trait, method, pred_env combination

# Standardize the cumulative distance
add_one_env_pred_stand <- add_one_env_pred1 %>% 
  # group_by(method) %>% 
  # mutate(distance = scale(distance)) %>%
  group_by(trait, method, pred_env) %>% 
  # mutate(cum_mean_dist = cummean(distance)) %>%
  mutate(n = 1, n_env = cumsum(n)) %>%
  ## Remove observations in which the number of environments is greater than the
  ## minimum for any trait, method, pred_env combination
  group_by(trait, method, n_env) %>% 
  filter(n() > n_env) %>%
  group_by(trait, method, pred_env) %>%
  mutate(cum_mean_scale = scale(cum_mean_dist)) %>%
  ungroup() %>%
  mutate(cum_mean_scale = cum_mean_scale - min(cum_mean_scale),
         env_add = as.factor(n_env),
         method = parse_factor(method, levels = c("D", "FA", "PCA", "EC_one_dist", "EC_multi_dist")))

# Summarize across all environments for a method
add_one_env_pred_summ <- add_one_env_pred_stand %>% 
  group_by(trait, method, env_add) %>% 
  summarize(mean_cor = mean(cor), se_cor = sd(cor, na.rm = T) / sqrt(n()), 
            avg_dist = mean(distance)) %>%
  mutate(cum_mean_dist = cummean(avg_dist),
         cum_mean_scale = scale(cum_mean_dist)) %>%
  ungroup() %>%
  mutate(cum_mean_scale = cum_mean_scale - min(cum_mean_scale))



# add_one_env_pred_stand %>%
(g_add_one_env <- add_one_env_pred_summ %>%
  # filter(pred_env == "STP16") %>%
  ggplot(aes(x = cum_mean_scale, y = mean_cor, col = method, shape = method)) +
  geom_point() +
  geom_line() +
  # geom_ribbon(aes(ymin = mean_cor - se_cor, ymax = mean_cor + se_cor), alpha = 0.05) +
  # geom_smooth(method = "lm", formula = y ~ poly(x, 2), se = FALSE) +
  facet_grid(trait ~ ., scales = "free_y") +
  ylab("Prediction Accuracy") +
  xlab("Mean Distance to Validation Environment") +
  labs(
    title = "Prediction Accuracy Upon Adding More Distant Environments",
    subtitle = "For each method, use data from increasingly distance environments to predict a\nsingle environment."
  ) +
  theme_bw())
  
# Save
save_file <- file.path(fig_dir, "add_one_env_acc.jpg")
ggsave(filename = save_file, plot = g_add_one_env, width = 8, height = 6)
 
```


Plot for a single trait all environments

```{r all.env}

# Plot the trend lines for all environments for a single trait
add_one_env_pred_stand %>% 
  filter(trait == "GrainYield") %>% 
  group_by(method, pred_env) %>% 
  # Scale the cumulative mean distance by each method and prediction environment
  mutate(cum_mean_dist = scale(cum_mean_dist)) %>%
  ggplot(aes(x = cum_mean_dist, y = cor, col = pred_env)) + 
  geom_point() + 
  geom_line() + 
  facet_wrap(~ method, ncol = 2) +
  theme_bw()


```






Using the clustering procedures from above, perform predictions among mega-environments

```{r cluster.pred}

# Load the data 
load_file <- file.path(proj_dir, "Predictions/Results/cluster_predictions.RData")
load(load_file)

## Pull out the no-cluster results
pred_acc_no_cluster <- pred_acc_results %>%
  unnest(acc) %>% 
  select(-`NA`) %>%
  mutate(method = str_replace_all(method, "_clust$", ""), 
         method = parse_factor(method, levels = c("D", "FA", "PCA", "EC_one", "EC_multi", "no_cluster")),
         pred_env = as.factor(pred_env),
         k = 1) %>%
  filter(method == "no_cluster")

pred_acc_results1 <- pred_acc_results %>% 
  unnest(acc) %>% 
  select(-`NA`) %>%
  mutate(method = str_replace_all(method, "_clust$", ""), 
         method = parse_factor(method, levels = c("D", "FA", "PCA", "EC_one", "EC_multi", "no_cluster")),
         pred_env = as.factor(pred_env)) %>%
  complete(trait, method, pred_env, population, k) %>%
  filter(method != "no_cluster")

# How many environments have no predictions?
n_blank_env <- pred_acc_results1 %>% 
  group_by(pred_env) %>% 
  summarize(p_na = mean(is.na(r_hat))) %>%
  filter(p_na == 1) %>%
  nrow()


# Join the cluster-based and non cluster-based results
pred_acc_comparison <- pred_acc_results1 %>%
  filter(k == 5) %>%
  full_join(., select(pred_acc_no_cluster, trait, pred_env:CI_upper), by = c("trait", "pred_env")) %>%
  # Is the cluster accuracy better than the non-cluster accuracy?
  mutate(cluster_better = r_hat.x >= r_hat.y,
         cluster_worse = r_hat.x < r_hat.y,
         cluster_sig_better = r_hat.x > CI_upper.y,
         cluster_sig_worse = r_hat.x < CI_lower.y)

# How often is some form of clustering better than not clustering?
pred_acc_comparison %>%
  group_by(trait, population, pred_env) %>%
  summarize(n_better = sum(cluster_better, na.rm = T),
            n_worse = sum(cluster_worse, na.rm = T),
            n_sig_better = sum(cluster_sig_better, na.rm = T),
            n_sig_worse = sum(cluster_sig_worse, na.rm = T)) %>%
  group_by(trait, population) %>%
  summarize(prop_one_better = mean(n_better >= 1),
            prop_all_worse = mean(n_better == 0),
            prop_one_sig_better = mean(n_sig_better >= 1))

# How often are different forms of clustering better than not clustering?
pred_acc_comparison_by_method <- pred_acc_comparison %>%
  group_by(trait, population, method) %>%
  summarize(prop_better = mean(cluster_better, na.rm = T),
            prop_worse = mean(cluster_worse, na.rm = T),
            prop_sig_better = mean(cluster_sig_better, na.rm = T),
            prop_sig_worse = mean(cluster_sig_worse, na.rm = T))

# Plot
(g_pred_acc_comp <- pred_acc_comparison_by_method %>%
    gather(metric, value, -trait:-method) %>%
    mutate(metric = parse_factor(metric, levels = c("prop_sig_better", "prop_better",
                                                    "prop_worse", "prop_sig_worse"))) %>%
    ggplot(aes(x = metric, y = value, fill = method)) +
    geom_col(position = "dodge") +
    facet_grid(trait ~ population) +
    ylim(c(0,1)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      title = "Proportion of Superior/Inferior Clustering",
      subtitle = "Proportion of observations in which the clustering method is superior or inferior to not clustering."
  ))

save_file <- file.path(fig_dir, "cluster_method_comparison.jpg")
ggsave(filename = save_file, plot = g_pred_acc_comp, width = 8, height = 6)
            

```


For each of $k \in \{3, ..., 6\}$, plot the comparison among clustering methods and non-clustering

```{r plot.k}

# Iterate over 
Kset <- unique(pred_acc_results_plot$k)

for (K in Kset) {
  
  # Plot the accuracy to predict each environment under different clustering procedures
  (g_pred_clust_all <- pred_acc_results1 %>%
     filter(population != "tp", k == K) %>%
     # Add the no-cluster data
     bind_rows(., pred_acc_no_cluster) %>%
     # Filter completely blank envs
     group_by(pred_env) %>%
     filter(mean(is.na(r_hat)) < 1) %>%
     ggplot(aes(x = pred_env, y = r_hat, group = method, fill = method)) + 
     labs(
       title = "Prediction Accuracy Within Clusters",
       subtitle = str_c("Compared prediction accuracy of each environment under k = ", K, " clusters determined by all entries or without clustering"),
       caption = str_c("D: clustering using Ouyang (1995) distance measure;\nFA: clustering using a factor analysis and 2 environmental loadings;\nPCA: clustering using the first 2 PCs of the GEI BLUPs;\nEC_one: clustering using the first 2 PCs of one-year environmental covariables;\nEC_multi: clustering using the first 2 PCs of the ten-year average of environmental covariables\nNote: ", n_blank_env, " environments were removed because predictions could not be made.")
     ) +
     geom_col(position = "dodge") + 
     geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper, group = method), position = "dodge") +
     facet_grid(trait ~ .) +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
     theme_bw() +
     ylim(c(-0.75, 1)))
  
  # Save it
  save_file <- file.path(fig_dir, str_c("cluster_k", K, "_predictions_all.jpg"))
  ggsave(filename = save_file, plot = g_pred_clust_all, width = 12, height = 8)

  (g_pred_clust_tp <- pred_acc_results1 %>% 
    filter(population != "all", k == K) %>%
    # Add the no-cluster data
    bind_rows(., pred_acc_no_cluster) %>%
    # Filter completely blank envs
    group_by(pred_env) %>%
    filter(mean(is.na(r_hat)) < 1) %>%
    ggplot(aes(x = pred_env, y = r_hat, group = method, fill = method)) + 
    labs(
      title = "Prediction Accuracy Within Clusters",
      subtitle = str_c("Compared prediction accuracy of each environment under k = ", K, " clusters determined by training population entries or without clustering"),
      caption = str_c("D: clustering using Ouyang (1995) distance measure;\nFA: clustering using a factor analysis and 2 environmental loadings;\nPCA: clustering using the first 2 PCs of the GEI BLUPs;\nEC_one: clustering using the first 2 PCs of one-year environmental covariables;\nEC_multi: clustering using the first 2 PCs of the ten-year average of environmental covariables\nNote: ", n_blank_env, " environments were removed because predictions could not be made.")
    ) +
     geom_col(position = "dodge") + 
     geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper, group = method), position = "dodge") +
     facet_grid(trait ~ .) +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
     theme_bw() +
     ylim(c(-0.75, 1)))            

  # Save it
  save_file <- file.path(fig_dir, str_c("cluster_k", K, "_predictions_tp.jpg"))
  ggsave(filename = save_file, plot = g_pred_clust_tp, width = 12, height = 8)
  
}



```


It appears that the effect of clustering on the accuracy to predict each environment is highly dependent on the environment itself. Clustering seems to help in some cases - it is worth exploring the conditions under which prediction accuracy is improved for an environmen (compared to not clustering).

Hypothesis: the heritability 




For each of the clustering methods, plot the comparison among k clusters versus no clustering


```{r plot.methods}

# Iterate over 
methods_set <- unique(pred_acc_results_plot$method)

for (met in methods_set) {
  
  # Plot the accuracy to predict each environment under different clustering procedures
  (g_pred_clust_all <- pred_acc_results1 %>%
     filter(population != "tp", method == met) %>%
     # Add the no-cluster data
     bind_rows(., pred_acc_no_cluster) %>%
     mutate(k = as.factor(k)) %>%
     # Filter completely blank envs
     group_by(pred_env) %>%
     filter(mean(is.na(r_hat)) < 1) %>%
     ggplot(aes(x = pred_env, y = r_hat, group = k, fill = k)) + 
     labs(
       title = "Prediction Accuracy Within Clusters",
       subtitle = str_c("Compared prediction accuracy of each environment under method: ", met, " clusters determined by all entries or without clustering"),
       caption = str_c("Note: ", n_blank_env, " environments were removed because predictions could not be made.")
     ) +
     geom_col(position = "dodge") + 
     geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper, group = k), position = "dodge") +
     facet_grid(trait ~ .) +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
     theme_bw() +
     ylim(c(-0.75, 1)) +
     scale_fill_brewer(type = "qual", palette = "Accent"))
  
  # Save it
  save_file <- file.path(fig_dir, str_c("cluster_met", met, "_predictions_all.jpg"))
  ggsave(filename = save_file, plot = g_pred_clust_all, width = 12, height = 8)

  (g_pred_clust_tp <- pred_acc_results1 %>% 
    filter(population != "all", method == met) %>%
    # Add the no-cluster data
    mutate(k = as.factor(k)) %>%
    # Filter completely blank envs
    group_by(pred_env) %>%
    filter(mean(is.na(r_hat)) < 1) %>%
    ggplot(aes(x = pred_env, y = r_hat, group = k, fill = k)) + 
    labs(
      title = "Prediction Accuracy Within Clusters",
      subtitle = str_c("Compared prediction accuracy of each environment under method: ", met, " clusters determined by training population entries or without clustering"),
      caption = str_c("Note: ", n_blank_env, " environments were removed because predictions could not be made.")
    ) +
     geom_col(position = "dodge") + 
     geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper, group = k), position = "dodge") +
     facet_grid(trait ~ .) +
     theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
     theme_bw() +
     ylim(c(-0.75, 1)) +
     scale_fill_brewer(type = "qual", palette = "Accent"))

  # Save it
  save_file <- file.path(fig_dir, str_c("cluster_met", met, "_predictions_tp.jpg"))
  ggsave(filename = save_file, plot = g_pred_clust_tp, width = 12, height = 8)
  
}



```


Model differences among prediction accuracy


```{r cluster.mod}

# Analyze the two populations and traits separately
cluster_mod <- pred_acc_results1 %>% 
  group_by(population, trait) %>% 
  filter(k == as.factor(k)) %>%
  do(mod = lm(r_hat ~ method + pred_env + k + method:pred_env, data = .)) %>%
  mutate(summary = list(summary(mod)),
         anova = list(anova(mod)))

# Check which terms are significant
cluster_sig <- cluster_mod %>%
  mutate(anova = list(broom::tidy(anova))) %>%
  unnest(anova) %>%
  filter(term != "Residuals") %>% 
  group_by(term) %>% 
  summarize(prop_sig = mean(p.value < 0.05))

## Run Tukey's to get significant method and method:pred_env comparisons
cluster_tukeys <- cluster_mod %>% 
  mutate(tukeys_method = list(TukeyHSD(aov(mod), which = "method")),
         tukeys_method_tidy = list(broom::tidy(tukeys_method)))
  
# Significant method comparisons
cluster_tukeys %>% 
  unnest(tukeys_method_tidy) %>% 
  filter(adj.p.value < 0.05)



```





## Appendix

### Cluster Testing

Use the gauch_soy dataset to test these procedures

```{r app.setup}

# Find balanced environments
gauch_soy <- gauch.soy %>% 
  modify_if(is.factor, as.character) %>%
  group_by(env, gen) %>% 
  filter(n_distinct(rep) == 4) %>%
  group_by(env) %>%
  filter(n_distinct(gen) == 7) %>%
  ungroup() %>%
  mutate(ge = interaction(gen, env, sep = ":"))

```



#### Method 1 - Distance and Gap Method

```{r D}
# Fit a model for the base heritability
base_mod <- lmer(yield ~ (1|gen) + env + (1|gen:env) + (1|env:rep), data = gauch_soy)

# Calculate the base heritability
herit_base <- base_herit(mod = base_mod)




# Find the pairwise environmental distances
D <- dist_env(x = gauch_soy)

# Max clusters
max_K <- n_distinct(gauch_soy$env) - 1

# Use gap method to determine mega-environments
D_cluster <- clusGap(x = as.matrix(D), FUNcluster = hclusCut, 
                     K.max = max_K, B = 500, verbose = FALSE)

# Determine the optimal number of clusters by the "firstSEmax" method
opt_clust <- maxSE(D_cluster$Tab[,"gap"], D_cluster$Tab[,"SE.sim"], method = "firstSEmax", SE.factor = 1)

# Cluster and cut the tree
clusters <- hclusCut(x = D, k = 2)$cluster %>%
  data_frame(env = names(.), cluster = .)

# Assign clusters to the dataset
gauch_soy_clust <- gauch_soy %>%
  full_join(., clusters, "env") %>%
  mutate(cluster = as.factor(cluster))


# Fit a new model with clusters
clust_mod <- lmer(yield ~ (1|gen) + env + (1|env:rep) + (1|gen:env) + (1|gen:env:cluster), 
                  data = gauch_soy_clust)

# Heritability
(herit_clust <- clust_herit(clust_mod))

# Combine
herit <- add_row(herit_clust, selection = "base", heritability = herit_base)



```


Attempt here an iterative procedure where clusters are formed based on the heritability of selection within the clusters

```{r clust.iter}

# Max clusters
max_K <- n_distinct(gauch_soy$env) - 1

# Build a data.frame
cluster_out <- data_frame(k = seq(max_K))

# Iterate over clusters
cluster_herit <- cluster_out %>%
  by_row(function(line) {
    
    # Cluster and cut the tree
    clusters <- hclusCut(x = D, k = line$k)$cluster %>%
      data_frame(env = names(.), cluster = .)

    # Assign clusters to the dataset
    gauch_soy_clust <- left_join(gauch_soy, clusters, "env") %>%
      mutate(cluster = as.factor(cluster))


    # Fit a new model with clusters
    clust_mod <- lmer(yield ~ (1|gen) + env + (1|env:rep) + (1|gen:env) + (1|gen:env:cluster), 
                      data = gauch_soy_clust)
    
    clust_herit(clust_mod) }, .to = "out_df")


# Plot
cluster_herit %>%
  unnest() %>%
  ggplot(aes(x = k, y = heritability, group = selection, col = selection)) +
  geom_point() +
  geom_line()



```


#### Method 2 - PCA of GxE BLUP effects

```{r gxe.blup.pca}

# GxE term
ge_term <- "ge"

# Re-fit the base model
base_mod <- lmer(yield ~ (1|gen) + env + (1|ge) + (1|env:rep), data = gauch_soy)

# Get the interaction blups and form a matrix
ge_effect <- ranef(base_mod)[[ge_term]] %>%
  rownames_to_column("grp") %>%
  separate(grp, c("gen", "env")) %>%
  rename(effect = `(Intercept)`) %>%
  spread(env, effect) %>% 
  remove_rownames() %>% 
  column_to_rownames("gen") %>% 
  as.matrix()

# Run PCA
ge_svd <- prcomp(ge_effect)

# Variance explained by first two PCs
(ge_svd$sdev / sum(ge_svd$sdev))[1:2] %>%
  structure(names = c("PC1", "PC2"))

# Plot
plot(ge_svd$rotation)

# Calculate a distance using first two PCs
D2 <- dist(ge_svd$rotation[,1:2])

plot(hclust(D2, method = "average"))


## Iterate over k = 1, 2, ..., K clusters and calculate within and between H

# Max clusters
max_K <- n_distinct(gauch_soy$env) - 1

# Use gap method to determine mega-environments
D2_cluster <- clusGap(x = as.matrix(D2), FUNcluster = hclusCut, 
                     K.max = max_K, B = 500, verbose = FALSE)

# Determine the optimal number of clusters by the "firstSEmax" method
opt_clust <- maxSE(D2_cluster$Tab[,"gap"], D2_cluster$Tab[,"SE.sim"], method = "firstSEmax", SE.factor = 1)

# Build a data.frame
cluster_out <- data_frame(k = seq(max_K))

# Iterate over clusters
cluster_herit <- cluster_out %>%
  by_row(function(line) {
    
    # Cluster and cut the tree
    clusters <- hclusCut(x = D2, k = line$k)$cluster %>%
      data_frame(env = names(.), cluster = .)

    # Assign clusters to the dataset
    gauch_soy_clust <- left_join(gauch_soy, clusters, "env") %>%
      mutate(cluster = as.factor(cluster))


    # Fit a new model with clusters
    clust_mod <- lmer(yield ~ (1|gen) + env + (1|env:rep) + (1|gen:env) + (1|gen:env:cluster), 
                      data = gauch_soy_clust)
    
    clust_herit(clust_mod) }, .to = "out_df")


# Plot
cluster_herit %>%
  unnest() %>%
  ggplot(aes(x = k, y = heritability, group = selection, col = selection)) +
  geom_point() +
  geom_line() + 
  geom_vline(xintercept = opt_clust)
  


```


#### Method 3 - Factor Analysis

The factor analysis is performed on the random effect of the *i*th genotype in the *j*th environment

```{r factor.analysis}

library(psych)

# Response of genotype in environment
gauch_soy_geno_mean_df <- gauch_soy %>% 
  group_by(gen, env) %>% 
  summarize(mean = mean(yield)) %>%
  mutate(ge = interaction(gen, env))

gauch_soy_geno_mean <- gauch_soy_geno_mean_df%>% 
  spread(env, mean) %>% 
  as.data.frame() %>% 
  remove_rownames() %>% 
  column_to_rownames("gen") %>%
  scale() %>%
  as.data.frame()

fa2 <- fa(r = gauch_soy_geno_mean, nfactors = 2, rotate = "varimax")

# Get the loadings and residuals
delta <- fa2$loadings
psi <- diag(fa2$uniquenesses)

# Estimate of the correlation matrix
sigma <- tcrossprod(delta) + psi

# Identity matrix for the relationship between genotypes
A <- diag(n_distinct(gauch_soy$gen)) %>%
  structure(dimnames = list(unique(gauch_soy$gen), unique(gauch_soy$gen)))

G <- kronecker(sigma, A, make.dimnames = TRUE) 

# Model frame
mf <- model.frame(formula = mean ~ gen + env + ge, data = gauch_soy_geno_mean_df)

y <- model.response(mf)
X <- model.matrix(~ env, data = mf)
Zlist <- model.matrix(~ ge, data = mf)

fa_fit <- mixed.solve(y = y, X = X, Z = Zlist$ge$Z, K = G)

# Cluster using the environmental loadings
delta_dist <- hclust(dist(delta), method = "average")
max_K <- length(delta_dist$labels) - 1

# Iterate over cluster numbers
# Assign clusters
# Refit the FA model using clusters instead of environments
# Find the loadings and apply to all environments in the cluster
cluster_out <- data_frame(k = seq(max_K, 1))

# Iterate over clusters
cluster_herit <- cluster_out %>%
  by_row(function(line) {
    
    # Cut the tree
    clusters <- cutree(delta_dist, k = line$k) %>%
      data_frame(env = names(.), cluster = .) %>%
      mutate(cluster = str_c("C", cluster))
    
    gauch_soy_geno_mean_df <- gauch_soy %>% 
      left_join(., clusters, "env") %>%
      group_by(gen, cluster) %>% 
      mutate(mean = mean(yield)) %>%
      distinct(gen, env, cluster, mean)

    gauch_soy_geno_mean <- gauch_soy_geno_mean_df %>% 
      distinct(gen, cluster, mean) %>%
      spread(cluster, mean) %>% 
      as.data.frame() %>% 
      remove_rownames() %>% 
      column_to_rownames("gen") %>%
      scale() %>%
      as.data.frame()

    fa2 <- fa(r = gauch_soy_geno_mean, nfactors = 2, rotate = "varimax")

    # Get the loadings and residuals
    delta <- fa2$loadings
    psi <- fa2$uniquenesses %>%
      data_frame(cluster = names(.), psi = .)
    
    # Convert loadings to data frame and merge
    delta_df <- structure(delta, class = "matrix") %>% 
      as.data.frame() %>% 
      rownames_to_column("cluster") 
    
    # Merge
    cluster_att_merge <- list(gauch_soy_geno_mean_df, delta_df, psi) %>% 
      reduce(left_join, "cluster") %>%
      ungroup() %>% 
      distinct(env, MR1, MR2, psi) %>% 
      as.data.frame() %>%
      column_to_rownames("env") %>% 
      as.matrix()
    
    delta_mat <- cluster_att_merge[,c("MR1", "MR2")]
    psi_mat <- cluster_att_merge[,"psi"]
    
    sigma <- tcrossprod(delta_mat) + diag(psi_mat)
    
    # New covariance matrix
    G <- kronecker(sigma, A, make.dimnames = TRUE) 

    # Solve
    fa_fit <- mixed.solve(y = y, X = X, Z = Zlist, K = G)
    
    # Assign clusters to the dataset
    gauch_soy_clust <- left_join(gauch_soy, clusters, "env") %>%
      mutate(cluster = as.factor(cluster))


    # Fit a new model with clusters
    clust_mod <- lmer(yield ~ (1|gen) + env + (1|env:rep) + (1|gen:env) + (1|gen:env:cluster), 
                      data = gauch_soy_clust)
    
    clust_herit(clust_mod) }, .to = "out_df")



# Fit full model
mixed.solve()
fa_fit <-

```

