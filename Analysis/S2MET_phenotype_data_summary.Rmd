---
title: "S2MET Phenotypic Data Summary"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

## Introduction

This notebook will provide some phenotyping data summaries for the S2MET project. It will include:

1. Basic model for g + e + gxe
2. Heritability estimates
3. Correlations among environments

```{r prep}

library(tidyverse)
library(broom)
library(stringr)
library(readxl)
library(modelr)
library(pbr)
library(rrBLUP)
library(ggridges)

# The head directory
proj_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET/"

source(file.path(proj_dir, "source.R"))

```


## Basic Summaries

Visualization of distributions

```{r pheno.viz}

# Sort on grain yield environmental mean
env_order <- S2_MET_BLUEs %>% 
  mutate_if(is.character, as.factor) %>% 
  group_by(environment, trait) %>% 
  mutate(env_mean = mean(value, na.rm = TRUE)) %>% 
  filter(trait == "GrainYield") %>% 
  complete(environment) %>%
  arrange(env_mean) %>%
  pull(environment) %>% 
  unique()

(g_met_dist <- S2_MET_BLUEs %>%
  mutate(environment = parse_factor(environment, levels = env_order)) %>%
  ggplot(aes(x = value, y = environment, fill = environment)) +
  geom_density_ridges() +
  facet_grid(. ~ trait, scales = "free_x") +
  scale_fill_discrete(guide = FALSE) +
  ylab("Environment") +
  xlab("") +
  labs(
    title = "Trait Distributions in All Environments"
  ))

# Sort

# Save it
save_file <- file.path(fig_dir, "met_trait_dist.jpg")
ggsave(filename = save_file, plot = g_met_dist, width = 7, height = 5)


```


Look at the number of lines per environment

```{r line.summ}

# Find the total number of possible line x environment combinations and find
# the proportion that are observed for each trait
(prob_observed <- S2_MET_BLUEs %>% 
  distinct(trait, environment, line_name) %>%
  mutate(observed = TRUE) %>% 
  complete(trait, environment, line_name, fill = list(observed = FALSE)) %>%
  group_by(trait) %>%
  summarize(prop_obs = mean(observed)))


```




Find the proportion of unbalance in the dataset

Do this for the TP, then for the VP, then for both

```{r prop.unbal}

s2_met_tidy_count <- s2_met_tidy_filt %>%
  # Add a dummy variables for all observations
  mutate(dummy = 1) %>%
  distinct(trait, line_name, environment, dummy) %>%
  select(trait, line_name, environment, dummy)

# Create count tables for the TP, then the VP
s2_met_tidy_count_tp <- s2_met_tidy_count %>% 
  filter(line_name %in% tp)

s2_met_tidy_count_vp <- s2_met_tidy_count %>% 
  filter(line_name %in% vp)

# Find the proportion of balance
tp_bal <- s2_met_tidy_count_tp %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy)) %>%
  mutate(pop = "tp")

vp_bal <- s2_met_tidy_count_vp %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy))  %>%
  mutate(pop = "vp")

# Intersect the environments with both the TP and VP
common_env <- intersect(
  distinct(s2_met_tidy_count_tp, environment), 
  distinct(s2_met_tidy_count_vp, environment) )

# Filter the larger tidy set on these environments and find the level of balance
common_bal <- s2_met_tidy_count %>% 
  filter(environment %in% common_env$environment) %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy))  %>%
  mutate(pop = "all")

# Print
list(tp_bal, vp_bal, common_bal) %>% 
  reduce(full_join, by = c("trait", "prop_bal", "pop")) %>% 
  spread(trait, prop_bal)

```


## Heritability

### Between Environment


The heritability will be calcuted for each trait across all environments by fitting the following model:

$$
y_{ij} = \mu + g_i + t_j + (gt)_{ij} + \epsilon_{ij}
$$

where $y_{ij}$ is the adjusted mean of the *i*th genotype in the *j*th environment, $\mu$ is the grand mean, $g_i$ is the random effect of the *i*th genotype, $t_j$ is the fixed effect of the $j$th environment, $(gt)_{ij}$ is the random effect of the interaction between the $i$th genotype and the $j$th environment, and $\epsilon_{ij}$ is the error associated with the observation.

We will assume the random effects are distributed such that $g \sim N(0, \sigma^2_g)$, $(gt) \sim N(0, \sigma^2_{(gt)})$, and $\epsilon \sim N(0, \mathbf{R}\sigma^2_\epsilon)$, where $\mathbf{R}$ is a diagonal matrix with elements equal to the inverse of the variances of the adjusted genotype means.

This will be run on MSI?


```{r herit.across}

# Group by trait and fit the multi-environment model
stage_two_fits <- S2_MET_BLUEs %>%
  group_by(trait) %>%
  do({
    
    to_model <- droplevels(.) %>%
      mutate(value = scale(value))
    
    # Table of lines by environments (i.e. plots)
    plot_table <- xtabs(formula = ~ line_name + environment, data = to_model)
    
    # Find the number of environments
    n_e <- plot_table %>%
      ifelse(. > 1, 1, .) %>%
      rowSums() %>% 
      harm_mean()
    
    # Now replicates
    n_r <- plot_table %>% 
      harm_mean()
    
    # Define the models to fit
    forms <- formulas(~ value,
                      base = ~ environment + (1|line_name),
                      full = ~ environment + (1|line_name) + (1 | line_name:environment),
                      fuller = ~ environment + (1|line_name) + (1|line_name:year) + 
                        (1|line_name:location) + (1|line_name:location:year))

    # Lmer control
    lmer_control <- lmerControl(check.nobs.vs.nlev = "ignore", check.nobs.vs.nRE = "ignore")
        
    # Get the weights
    wts <- pull(to_model, std_error)^2
    
    # Fit the models and return
    fits <- fit_with(data = to_model, lmer, forms, weights = wts, control = lmer_control)
    
    # Return data_frame
    data_frame(fits = list(fits), n_e = n_e, n_r = n_r) })



```


First test for significance of the $gt$ term using a liklihood ratio test

The likelihood ratio is calculated as

$$
LR = -2[\log(L_{Red}) - \log(L_{Full})]
$$

The $LR$ is $\chi^2$ distributed with 1 degree of freedom (since we dropped one variance component to get the reduced model). The hypothesis test is $H_0: \sigma^2_i = 0$ and $H_A: \sigma^2_i > 0$

```{r lrt}

(stage_two_lrt <- stage_two_fits %>% 
  mutate(llik = map(fits, ~map_df(., logLik))) %>% 
  unnest(llik) %>%
  select(-fits:-n_r, -fuller) %>%
  mutate(lr = -2 * (base - full),
         p_value = pchisq(q = lr, df = 1, lower.tail = FALSE) / 2))


```




The broad-sense heritability is calculated on a entry-mean basis according to the formula

$$
H = \frac{ \sigma^2_G }{ \sigma^2_G + \frac{\sigma^2_{GE}}{r} + \frac{\sigma^2_R}{er} }
$$

for overall heritability calculations, and 

$$
H = \frac{ \sigma^2_G }{ \sigma^2_G  + \frac{\sigma^2_R}{r} }
$$


where $e$ is the number of environments and $r$ is the number of replicates. In the case of an augmented design, where the number of replicates is uneven, the following formula is used to calculate the harmonic mean of the number of replications:

$$
p_h = \frac{n}{\sum^n_{i=1} \frac{1}{p_i}}
$$

where $p_h$ is the harmonic mean, $n$ is the number of genotypes, and $p_i$ is the number of replicates of the *i*th genotype.

Now calculate heritability across all environments



```{r calc.herit.all}

# Extract the full model and calculate heritability
stage_two_herit <- stage_two_fits %>% 
  ungroup() %>% 
  mutate(full_fit = lapply(.$fits, "[[", "full")) %>%
  group_by(trait) %>%
  do({
    # Calculate heritability
    suppressWarnings(herit_boot(object = .$full_fit[[1]], 
                        exp = "line_name / (line_name + (line_name:environment / n_e) + (Residual / n_r))", 
                        boot.reps = 500, n_e = .$n_e, n_r = .$n_r)) })
    

# Plot
stage_two_herit %>% 
  mutate(H_corr = heritability - bias) %>%
  ggplot(aes(x = trait, y = H_corr, ymin = ci_lower, ymax = ci_upper)) +
  geom_col() +
  geom_errorbar(width = 0.5) +
  ylab("Heritability") +
  xlab("Trait") +
  labs(
    title = "Broad-Sense Heritability of Each Trait Across All Environments",
    subtitle = "Estimates have been corrected for bias and error bars reflect\na 95% confidence interval of 500 bootstrap replications.",
    caption = expression("Equation: "~frac(sigma[g]^2, sigma[g]^2 + frac(sigma[ge]^2, n[e]) + 
                                                  frac(sigma[epsilon]^2, n[e]*n[r]))))
  )

  
```
  

What is the proportion of each variance component to the total phenotypic variance?

```{r var.prop}

stage_two_prop_varcomp <- stage_two_fits %>% 
  ungroup() %>% 
  mutate(full_fit = lapply(.$fits, "[[", "full")) %>%
  group_by(trait) %>% 
  mutate(var_comp = list(as.data.frame(VarCorr(full_fit[[1]])))) %>%
  # Calculate variance components
  unnest(var_comp) %>% 
  select(trait:grp, vcov) %>% 
  spread(grp, vcov) %>% 
  rename(varG = line_name) %>%
  mutate(varGE = `line_name:environment` / n_e, 
         varR = Residual / (n_e * n_r), 
         varP = varG + varGE + varR) %>%
  select(trait, starts_with("var")) %>% 
  gather(var_comp, value, -trait, -varP) %>%
  mutate(prop_value = value / varP)

# Plot
stage_two_prop_varcomp %>%
  ggplot(aes(x = trait, y = prop_value, fill = var_comp)) +
  geom_col() +
  ylab("Proportion") +
  xlab("Trait") + 
  scale_fill_discrete(guide = guide_legend(title = "Variance Component")) +
  labs(
    title = "Proportion of Variance Components to Phenotypic Variance"
  ) +
  theme_bw()


```


## Environmental Correlations

Estimate the genetic variance-covariance matrix across environments using the method by @Lado2016a and @Rebonato2000

In this method, a correlation matrix is first calculated using Pearson correlations, then this correlation matrix is decomposed to estimate the genetic correlation.



```{r functions}

# Define a function to correct the correlation matrix
corr_decomp <- function(x) {
  
  # Decomposition
  s <- eigen(x)

  # Set anything less than 0 to 0
  la <- ifelse(s$values <= 0, 0, s$values)

  # Get the eigenvectors
  S <- s$vectors
  
  # Diagonal matrix of eigenvalues
  La <- diag(la)

  B_prime <- S %*% sqrt(La)

  # Normalization matrix
  T_mat <- solve(diag(as.vector(S^2 %*% la)))

  # Return B matrix
  B <- sqrt(T_mat) %*% B_prime * -1
  
  # tcrossprod
  C_prime <- tcrossprod(B)
  dimnames(C_prime) <- dimnames(x)
  return(C_prime)
  
}

```



Calculate the genetic correlation between environments using the training population

```{r env.corr.tp}

# Calculate environmental correlations using all pairwise information on the tp
# First subset the data
pheno_use <- S2.MET.BLUE %>%
  filter(year != 2014)

# Extract tp and correlate
env_cor <- pheno_use %>% 
  filter(line_name %in% tp) %>%
  select(trait, line_name, environment, value) %>%
  # Split by trait
  split(.$trait) %>%
  map(spread, environment, value) %>%
  map(group_by, trait) %>%
  map(function(trait_mat) do(trait_mat, cor_mat = cor(.[,-1:-2], use = "pairwise.complete.obs", method = "pearson"))) %>%
  bind_rows()

# For each matrix, adjust using the function above
env_cor_tp <- env_cor %>% 
  mutate(adj_cor_mat = list(corr_decomp(cor_mat)))

# Reconfigure the data and plot a heatmap
env_cor_tp_tidy <- env_cor_tp %>%
  split(.$trait) %>%
  map(group_by, trait) %>%
  map(function(trait_df) do(trait_df, {
    .$adj_cor_mat %>% as.data.frame() %>% rownames_to_column("env1") %>% gather(env2, correlation, -env1) }) ) %>%
  bind_rows()

env_cor_tp_tidy %>%
  ggplot(aes(x = env1, y = env2, fill = correlation)) +
  geom_tile() +
  scale_fill_gradientn(colors = c("blue", "white", "red"), na.value = "transparent", breaks = c(-1, 0, 1), limits = c(-1, 1), 
                       guide = guide_colorbar(title = "Genetic Correlation")) +
  ylab("Environment 2") +
  xlab("Environment 1") +
  facet_wrap(~ trait, nrow = 2, ncol = 2) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
    axis.text.y = element_text(size = 6)
  ) 


```


Calculate the genetic correlation between environments using the checks

```{r env.corr.chk}

# Calculate environmental correlations using all pairwise information on the checks
# First subset the data
pheno_use <- S2.MET.BLUE %>%
  filter(year != 2014)

# Extract tp and correlate
env_cor <- pheno_use %>% 
  filter(line_name %in% checks,
         !str_detect(trial, "S2C1F4")) %>%
  select(trait, line_name, environment, value) %>%
  # Split by trait
  split(.$trait) %>%
  map(spread, environment, value) %>%
  map(group_by, trait) %>%
  map(function(trait_mat) do(trait_mat, cor_mat = cor(.[,-1:-2], use = "pairwise.complete.obs", method = "pearson"))) %>%
  bind_rows()

# For each matrix, adjust using the function above
env_cor_chk <- env_cor %>% 
  mutate(adj_cor_mat = list(corr_decomp(cor_mat)))

# Reconfigure the data and plot a heatmap
env_cor_chk_tidy <- env_cor_chk %>%
  split(.$trait) %>%
  map(group_by, trait) %>%
  map(function(trait_df) do(trait_df, {
    .$adj_cor_mat %>% as.data.frame() %>% rownames_to_column("env1") %>% gather(env2, correlation, -env1) }) ) %>%
  bind_rows()

env_cor_chk_tidy %>%
  ggplot(aes(x = env1, y = env2, fill = correlation)) +
  geom_tile() +
  scale_fill_gradientn(colors = c("blue", "white", "red"), na.value = "transparent", breaks = c(-1, 0, 1), limits = c(-1, 1), 
                       guide = guide_colorbar(title = "Genetic Correlation")) +
  ylab("Environment 2") +
  xlab("Environment 1") +
  facet_wrap(~ trait, nrow = 2, ncol = 2) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
    axis.text.y = element_text(size = 6)
  ) 

```


Save the correlation matrices for further use

```{r}

save_file <- file.path(proj_dir, "Environmental_Variables/env_cov_mat_correlation.RData")
save("env_cor_tp", "env_cor_chk", file = save_file)


```

