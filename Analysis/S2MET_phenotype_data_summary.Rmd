---
title: "S2MET Phenotypic Data Summary"
output: html_notebook
bibliography: C:/Users/Jeff/Documents/Literature/library.bib
---

## Introduction

This notebook will provide some phenotyping data summaries for the S2MET project. It will include:

1. Basic model for g + e + gxe
2. Heritability estimates
3. Correlations among environments

```{r prep}

library(tidyverse)
library(broom)
library(stringr)
library(readxl)
library(pbr)
library(rrBLUP)
library(ggridges)

## Directories
proj_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET/"
fig_dir <- file.path(proj_dir, "Figures/")
pred_dir <- file.path(proj_dir, "Predictions")
geno_dir <-  "C:/Users/Jeff/Google Drive/Barley Lab/Projects/Genomic Selection/Genotypic Data/GBS Genotype Data/"
env_var_dir <- file.path(proj_dir, "Environmental_Variables/")
pheno_dir <- file.path(proj_dir, "Phenotype_Data/")
entry_dir <- file.path(proj_dir, "Plant_Materials")
analysis_dir <- file.path(proj_dir, "Analysis")

# Load the phenotypic data
load(file.path(pheno_dir, "S2_MET_BLUEs.RData"))
# Load the genotypic data
load(file.path(geno_dir, "S2_genos_mat.RData"))

# Load an entry file
entry_list <- read_excel(file.path(entry_dir, "S2MET_project_entries.xlsx"))


# Grab the entry names that are not checks
tp <- entry_list %>% 
  filter(Class == "S2TP") %>% 
  pull(Line)

vp <- entry_list %>% 
  filter(Class == "S2C1R") %>% 
  pull(Line)

# Find the tp and vp that are genotypes
tp_geno <- intersect(tp, row.names(s2_imputed_mat))
vp_geno <- intersect(vp, row.names(s2_imputed_mat))

# Define the checks
checks <- entry_list %>% 
  filter(Class == "Check") %>% 
  pull(Line)

entries <- entry_list %>% 
  pull(Line)

# Extract the tp and vp from the G matrix
s2_imputed_mat_use <- s2_imputed_mat[c(tp_geno, vp_geno),]


```


## Basic Summaries

Visualization of distributions

```{r pheno.viz}

S2_MET_BLUEs %>%
  ggplot(aes(x = value, y = environment, fill = environment)) +
  geom_density_ridges() +
  facet_grid(. ~ trait, scales = "free_x")

```


Look at the number of lines per environment

```{r line.summ}

# Find the total number of possible line x environment combinations and find
# the proportion that are observed for each trait
(prob_observed <- S2_MET_BLUEs %>% 
  distinct(trait, environment, line_name) %>%
  mutate(observed = TRUE) %>% 
  complete(trait, environment, line_name, fill = list(observed = FALSE)) %>%
  group_by(trait) %>%
  summarize(prop_obs = mean(observed)))


```




Find the proportion of unbalance in the dataset

Do this for the TP, then for the VP, then for both

```{r prop.unbal}

s2_met_tidy_count <- s2_met_tidy_filt %>%
  # Add a dummy variables for all observations
  mutate(dummy = 1) %>%
  distinct(trait, line_name, environment, dummy) %>%
  select(trait, line_name, environment, dummy)

# Create count tables for the TP, then the VP
s2_met_tidy_count_tp <- s2_met_tidy_count %>% 
  filter(line_name %in% tp)

s2_met_tidy_count_vp <- s2_met_tidy_count %>% 
  filter(line_name %in% vp)

# Find the proportion of balance
tp_bal <- s2_met_tidy_count_tp %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy)) %>%
  mutate(pop = "tp")

vp_bal <- s2_met_tidy_count_vp %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy))  %>%
  mutate(pop = "vp")

# Intersect the environments with both the TP and VP
common_env <- intersect(
  distinct(s2_met_tidy_count_tp, environment), 
  distinct(s2_met_tidy_count_vp, environment) )

# Filter the larger tidy set on these environments and find the level of balance
common_bal <- s2_met_tidy_count %>% 
  filter(environment %in% common_env$environment) %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy))  %>%
  mutate(pop = "all")

# Print
list(tp_bal, vp_bal, common_bal) %>% 
  reduce(full_join, by = c("trait", "prop_bal", "pop")) %>% 
  spread(trait, prop_bal)

```


## Heritability

### Between Environment


The heritability will be calcuted for each trait across all environments by fitting the following model:

$$
y_{ij} = \mu + g_i + t_j + (gt)_{ij} + \epsilon_{ij}
$$

where $y_{ij}$ is the adjusted mean of the *i*th genotype in the *j*th environment, $\mu$ is the grand mean, $g_i$ is the random effect of the *i*th genotype, $t_j$ is the fixed effect of the $j$th environment, $(gt)_{ij}$ is the random effect of the interaction between the $i$th genotype and the $j$th environment, and $\epsilon_{ij}$ is the error associated with the observation.

We will assume the random effects are distributed such that $g \sim N(0, \sigma^2_g)$, $(gt) \sim N(0, \sigma^2_{(gt)})$, and $\epsilon \sim N(0, \mathbf{R}\sigma^2_\epsilon)$, where $\mathbf{R}$ is a diagonal matrix with elements equal to the inverse of the variances of the adjusted genotype means.

This will be run on MSI?


```{r herit.across}


# Group by trait and fit the multi-environment model
stage_two <- S2_MET_BLUEs %>%
  group_by(trait) %>%
  # Fit the models
  do({
    
    # Model formula
    form <- value ~ environment + (1|line_name) + (1|line_name:environment)
    form_reduced <- value ~ environment + (1|line_name)
    
    to_model <- droplevels(.)
    
    # Table of lines by environments (i.e. plots)
    plot_table <- xtabs(formula = ~ line_name + environment, data = to_model)
    
    # Find the number of environments
    n_e <- plot_table %>%
      ifelse(. > 1, 1, .) %>%
      rowSums() %>% 
      harm_mean()
    
    # Now replicates
    n_r <- plot_table %>% 
      harm_mean()
    
    wts <- pull(to_model, std_error)^2
    
    # Control for lmer
    lmer_control <- lmerControl(check.nobs.vs.nlev = "ignore", check.nobs.vs.nRE = "ignore")

    # Fit the model
    fit <- lmer(formula = form, data = to_model, control = lmer_control, weights = wts)
    
    # Fit a reduced model
    suppressWarnings(fit_reduced <- lmer(formula = form_reduced, data = to_model, control = lmer_control, 
                        weights = wts))
    
    # Calculate heritability
    suppressWarnings(herit <- herit_boot(object = fit, 
                        exp = "line_name / (line_name + (line_name:environment / n_e) + (Residual / n_r))", 
                        boot.reps = 500, n_e = n_e, n_r = n_r))
    
    bind_cols(data_frame(mod = list(fit), mod_reduced = list(fit_reduced),
                         n_e = n_e, n_r = n_r), herit) })

```


First test for significance of the $gt$ term using a liklihood ratio test

The likelihood ratio is calculated as

$$
LR = -2[\log(L_{Red}) - \log(L_{Full})]
$$

The $LR$ is $\chi^2$ distributed with 1 degree of freedom (since we dropped one variance component to get the reduced model). The hypothesis test is $H_0: \sigma^2_i = 0$ and $H_A: \sigma^2_i > 0$

```{r lrt}

# Calculate the log-likelihoods and LRT
log_likelihoods <- stage_two %>% 
  select(trait, contains("mod")) %>% 
  gather(type, model, -trait) %>% 
  mutate(logLik = map_dbl(model, logLik))

(LRT <- log_likelihoods %>%
  select(trait, type, logLik) %>% 
  spread(type, logLik) %>%
  mutate(lr = -2 * (mod_reduced - mod),
         p_value = pchisq(q = lr, df = 1, lower.tail = FALSE) / 2))



```




The broad-sense heritability is calculated on a entry-mean basis according to the formula

$$
H = \frac{ \sigma^2_G }{ \sigma^2_G + \frac{\sigma^2_{GE}}{r} + \frac{\sigma^2_R}{er} }
$$

for overall heritability calculations, and 

$$
H = \frac{ \sigma^2_G }{ \sigma^2_G  + \frac{\sigma^2_R}{r} }
$$


where $e$ is the number of environments and $r$ is the number of replicates. In the case of an augmented design, where the number of replicates is uneven, the following formula is used to calculate the harmonic mean of the number of replications:

$$
p_h = \frac{n}{\sum^n_{i=1} \frac{1}{p_i}}
$$

where $p_h$ is the harmonic mean, $n$ is the number of genotypes, and $p_i$ is the number of replicates of the *i*th genotype.

Now calculate heritability across all environments



```{r calc.herit.all}

# Plot
stage_two %>% 
  mutate(H_corr = heritability - bias) %>%
  ggplot(aes(x = trait, y = H_corr, ymin = ci_lower, ymax = ci_upper)) +
  geom_col() +
  geom_errorbar(width = 0.5) +
  ylab("Heritability") +
  xlab("Trait") +
  labs(
    title = "Broad-Sense Heritability of Each Trait Across All Environments",
    subtitle = "Estimates have been corrected for bias and error bars reflect\na 95% confidence interval of 500 bootstrap replications."
  )

# Calculate the proportion of the phenotypic variance explained by each variance component

  
```
  


## Environmental Correlations

Estimate the genetic variance-covariance matrix across environments using the method by @Lado2016a and @Rebonato2000

In this method, a correlation matrix is first calculated using Pearson correlations, then this correlation matrix is decomposed to estimate the genetic correlation.



```{r functions}

# Define a function to correct the correlation matrix
corr_decomp <- function(x) {
  
  # Decomposition
  s <- eigen(x)

  # Set anything less than 0 to 0
  la <- ifelse(s$values <= 0, 0, s$values)

  # Get the eigenvectors
  S <- s$vectors
  
  # Diagonal matrix of eigenvalues
  La <- diag(la)

  B_prime <- S %*% sqrt(La)

  # Normalization matrix
  T_mat <- solve(diag(as.vector(S^2 %*% la)))

  # Return B matrix
  B <- sqrt(T_mat) %*% B_prime * -1
  
  # tcrossprod
  C_prime <- tcrossprod(B)
  dimnames(C_prime) <- dimnames(x)
  return(C_prime)
  
}

```



Calculate the genetic correlation between environments using the training population

```{r env.corr.tp}

# Calculate environmental correlations using all pairwise information on the tp
# First subset the data
pheno_use <- S2.MET.BLUE %>%
  filter(year != 2014)

# Extract tp and correlate
env_cor <- pheno_use %>% 
  filter(line_name %in% tp) %>%
  select(trait, line_name, environment, value) %>%
  # Split by trait
  split(.$trait) %>%
  map(spread, environment, value) %>%
  map(group_by, trait) %>%
  map(function(trait_mat) do(trait_mat, cor_mat = cor(.[,-1:-2], use = "pairwise.complete.obs", method = "pearson"))) %>%
  bind_rows()

# For each matrix, adjust using the function above
env_cor_tp <- env_cor %>% 
  mutate(adj_cor_mat = list(corr_decomp(cor_mat)))

# Reconfigure the data and plot a heatmap
env_cor_tp_tidy <- env_cor_tp %>%
  split(.$trait) %>%
  map(group_by, trait) %>%
  map(function(trait_df) do(trait_df, {
    .$adj_cor_mat %>% as.data.frame() %>% rownames_to_column("env1") %>% gather(env2, correlation, -env1) }) ) %>%
  bind_rows()

env_cor_tp_tidy %>%
  ggplot(aes(x = env1, y = env2, fill = correlation)) +
  geom_tile() +
  scale_fill_gradientn(colors = c("blue", "white", "red"), na.value = "transparent", breaks = c(-1, 0, 1), limits = c(-1, 1), 
                       guide = guide_colorbar(title = "Genetic Correlation")) +
  ylab("Environment 2") +
  xlab("Environment 1") +
  facet_wrap(~ trait, nrow = 2, ncol = 2) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
    axis.text.y = element_text(size = 6)
  ) 


```


Calculate the genetic correlation between environments using the checks

```{r env.corr.chk}

# Calculate environmental correlations using all pairwise information on the checks
# First subset the data
pheno_use <- S2.MET.BLUE %>%
  filter(year != 2014)

# Extract tp and correlate
env_cor <- pheno_use %>% 
  filter(line_name %in% checks,
         !str_detect(trial, "S2C1F4")) %>%
  select(trait, line_name, environment, value) %>%
  # Split by trait
  split(.$trait) %>%
  map(spread, environment, value) %>%
  map(group_by, trait) %>%
  map(function(trait_mat) do(trait_mat, cor_mat = cor(.[,-1:-2], use = "pairwise.complete.obs", method = "pearson"))) %>%
  bind_rows()

# For each matrix, adjust using the function above
env_cor_chk <- env_cor %>% 
  mutate(adj_cor_mat = list(corr_decomp(cor_mat)))

# Reconfigure the data and plot a heatmap
env_cor_chk_tidy <- env_cor_chk %>%
  split(.$trait) %>%
  map(group_by, trait) %>%
  map(function(trait_df) do(trait_df, {
    .$adj_cor_mat %>% as.data.frame() %>% rownames_to_column("env1") %>% gather(env2, correlation, -env1) }) ) %>%
  bind_rows()

env_cor_chk_tidy %>%
  ggplot(aes(x = env1, y = env2, fill = correlation)) +
  geom_tile() +
  scale_fill_gradientn(colors = c("blue", "white", "red"), na.value = "transparent", breaks = c(-1, 0, 1), limits = c(-1, 1), 
                       guide = guide_colorbar(title = "Genetic Correlation")) +
  ylab("Environment 2") +
  xlab("Environment 1") +
  facet_wrap(~ trait, nrow = 2, ncol = 2) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
    axis.text.y = element_text(size = 6)
  ) 

```


Save the correlation matrices for further use

```{r}

save_file <- file.path(proj_dir, "Environmental_Variables/env_cov_mat_correlation.RData")
save("env_cor_tp", "env_cor_chk", file = save_file)


```

