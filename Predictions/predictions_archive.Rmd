---
title: "S2MET Predictions - Archive"
output: html_notebook
---











Use data across all 2016 environments for GrainYield

The methods will be divided into two sets of models: those that use environmental covariables and those that do not. Models will be those that use information on observed environments (from the TP) to predict unobserved genotypes in those environments (the VP). Eventually, however, we want to be able to predict unobserved genotypes in totally unobserved environments.

```{r filter.pheno}

env <- sort(c("STP16", "CRM16", "AID16"))
trt <- "GrainYield"

pheno_use <- pheno %>%
  filter(environment %in% env) %>%
  # filter(!environment %in% c("ALV16", "CPE16")) %>%
  filter(trait == trt) %>%
  droplevels()

# Subset the environment covariance matrices
Sig_E_tp <- E_tp %>% 
  filter(trait == trt) %>%
  .$adj_cor_mat %>%
  .[[1]] %>%
  subset(row.names(.) %in% env, env)

Sig_E_chk <- E_chk %>% 
  filter(trait == trt) %>%
  .$adj_cor_mat %>%
  .[[1]] %>%
  subset(row.names(.) %in% env, env)


# Retrieve just phenos for the tp
pheno_tp <- pheno_use %>%
  filter(line_name %in% tp)

# Retrieve just phenos for the vp
pheno_vp <- pheno_use %>%
  filter(line_name %in% vp)

# Convert to usable form
pheno_vp_use <- pheno_vp %>%
  select(line_name, environment, value) %>%
  mutate_at(vars(-value), as.character)

pheno_tp_use <- pheno_tp %>%
  select(line_name, environment, value) %>%
  mutate_at(vars(-value), as.character)

# Response variable input matrix
y <- pheno_tp_use %>% 
  unite(inter, line_name:environment, sep = ":") %>%
  data.frame(row.names = .$inter) %>%
  select(value) %>%
  as.matrix()


```

Generally, I will use notation from @Jarquin2014a and @Lopez-Cruz2015

### No Environmental Covariables

#### Main Effects Model 1 (Environments Fixed)

The first model is the main effects model, with no interaction. In this model, information on genotypes is borrowed by using genetic covariables (i.e. SNPs), however information on environments is not shared. It can be written as

Equation 1:
$$
y_{ij} = \mu + g_i + E_j + \epsilon_{ij}
$$


where $y_{ij}$ is the phenotypic observation of the $i$th genotype in the $j$th environment, $\mu$ is the grand mean (fixed), $g_i$ is the fixed effect of the $i$th genotype, $E_j$ is the random effect of the $j$th environment, and $\epsilon_{ij}$ is the randome error term associated with the $i$th genotype in the $j$th environment. In mixed model form, this equation can be re-written as

Equation 2:
$$
\mathbf{y = X\beta + Zu + e}
$$

where $\mathbf{X}$ is a design matrix of fixed effects (environments), $\mathbf{\beta}$ is a vector of fixed environmental effects, $\mathbf{Z}$ is a design matrix of random effects (genotypes) and $\mathbf{u}$ is a vector of genotype effects.

$\mathbf{u}$ is assumed to be a random variable such that $\mathbf{u} \sim N(0, \mathbf{G} \sigma^2_g)$, where $G$ is the genomic relationship matrix

Assumptions:

- The genetic variance ($\sigma^2_g$) is constant over environments.

In R code form


```{r main.eff.fixed, results='hide'}

# Define the X matrix
X <- model.matrix(~ -1 + environment, data = pheno_tp)

# Define the Z matrix
Z <- model.matrix(~ -1 + line_name, data = pheno_tp)


# Solve the mixed model
fit_Eg_fixed <- emmremlMultiKernel(y = y, X = X, Zlist = list(Z), Klist = list(A))

# Pull out estimates and predictions
beta <- fit_Eg_fixed$betahat %>% 
  data.frame(environment = row.names(.), ., row.names = NULL, stringsAsFactors = FALSE) %>% 
  mutate(environment = str_replace(environment, "environment", ""))

g <- fit_Eg_fixed$uhat %>% 
  data.frame(line_name = names(.), value = ., row.names = NULL, stringsAsFactors = FALSE) %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  rename(pred = value)

# Accuracy of the VP
g_vp <- g %>% 
  filter(line_name %in% vp)


Eg_fixed_acc <- full_join(g_vp, pheno_vp_use, by = c("line_name")) %>% 
  group_by(environment) %>%
  do(as.data.frame(boot_cor(.$pred, .$value, 1000)))


```

#### Main Effects Model 2 (Eg)

We re-write Equation 1 to reflect the interpretation of the environment effects as random instead of fixed:

Equation 3:
$$
\mathbf{y = X\beta + Zu + Wm + e}
$$

where $X$ is a design matrix of 1s, $\mathbf{\beta}$ is a vector of fixed effects (means), $\mathbf{Z}$ is a design matrix of that relates the phenotypic observations to the random genotypic effects, $\mathbf{u}$ is a vector of genotype effects, $\mathbf{W}$ is a design matrix relating the phenotypic observations to the random environmental effects, and $\mathbf{m}$ is a vector of environmental effects.

$\mathbf{u}$ is assumed to be a random variable such that $\mathbf{u} \sim N(0, \mathbf{G} \sigma^2_g)$, where $G$ is the genomic relationship matrix, and $\mathbf{m}$ is assumed to be a random variable such that $\mathbf{m} \sim N(0, \sigma^2_e)$.


In R code form


```{r main.eff.int}

# Define the X matrix
X <- matrix(1, nrow = nrow(y))

# Define the Z matrix
Z <- model.matrix(~ -1 + line_name, data = pheno_tp)

# Define the W matrix
W <- model.matrix(~ -1 + environment, data = pheno_tp)
# Define the covariance structure of this matrix (diag)
E <- diag(ncol(W)) %>%
  structure(dimnames = list(colnames(W), colnames(W)))

# Solve the mixed model
fit_Eg_rand <- emmremlMultiKernel(y = y, X = X, Zlist = list(Z, W), Klist = list(A, E), varbetahat = T, varuhat = T)

# Pull out estimates and predictions
beta <- fit_Eg_rand$betahat

rand <- fit_Eg_rand$uhat %>% 
  data.frame(line_name = names(.), value = ., row.names = NULL, stringsAsFactors = FALSE) %>%
  mutate(kernel = str_extract(line_name, pattern = "K_[0-9]"))

g <- rand %>%
  filter(kernel == "K_1") %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  rename(pred = value)

e <- rand %>%
  filter(kernel == "K_2") %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  rename(environment = line_name)

# Accuracy of the VP
g_vp <- g %>% 
  filter(line_name %in% vp)

Eg_rand_acc <- full_join(g_vp, pheno_vp_use, by = c("line_name")) %>% 
  group_by(environment) %>%
  do(as.data.frame(boot_cor(.$pred, .$value, 1000)))


```


#### Main Effects and Interaction Model 1 (Eg x E)

This model expands Equation 1 to include an interaction term between the random genotypic effects (informed by markers) and the environmental effects (information not shared).

Equation 4:
$$
y_{ij} = \mu + g_i + E_j + gE_{ij} + \epsilon_{ij}
$$

where $gE_{ij}$ is the random interaction effect of the $i$th genotype in the $j$th environment. In mixed model equation form, Equation 4 is written

Equation 5:
$$
\mathbf{y = X\beta + Zu + Wm + Vn + e}
$$

where $\mathbf{V}$ is a design matrix of random interaction effects and $\mathbf{n}$ is a vector of genotype-environment interaction effects.

$\mathbf{u}$ is assumed to be a random variable such that $\mathbf{u} \sim N(0, \mathbf{G} \sigma^2_g)$, where $\mathbf{G}$ is the genomic relationship matrix, $\mathbf{m}$ is assumed to be a random variable such that $\mathbf{m} \sim N(0, \sigma^2_e)$, and $\mathbf{n}$ is assumed to be a random variable such that $\mathbf{n} \sim N(0, \mathbf{\Sigma}  \sigma^2_{ge})$, where $\Sigma$ defines the covariance structure of the $\mathbf{n}$ effects and takes the form  $\mathbf{\Sigma = [Z_g G Z'_g] \cdot [W_e W'_e]}$, with $\cdot$ indicating the Hadamard product.

In R code form


```{r main.eff.rand}

# Define the X matrix
X <- matrix(1, nrow = nrow(y))

# Define the Z matrix
Z <- model.matrix(~ -1 + line_name, data = pheno_tp)

# Define the W matrix
W <- model.matrix(~ -1 + environment, data = pheno_tp)
# Define the covariance structure of this matrix (diag)
E <- diag(ncol(W)) %>%
  structure(dimnames = list(colnames(W), colnames(W)))

# Define the V matrix
V <- model.matrix(~ -1 + line_name:environment, data = pheno_tp)

# Define the covariance structure of this matrix
## Incidence matrix of all lines
Z_all <- model.matrix(~ -1 + line_name, data = pheno_use)
## Incidence matrix of all environments
W_all <- model.matrix(~ -1 + environment, data = pheno_use)

G_cov <- Z_all %*% A %*% t(Z_all)
E_cov <- W_all %*% t(W_all)

ge_comb <- interaction(pheno_use$line_name, pheno_use$environment, sep = ":")
GE <- matrixcalc::hadamard.prod(G_cov, E_cov) %>%
  structure(dimnames = list(ge_comb, ge_comb))

# Solve the mixed model
fit_EgxE <- emmremlMultiKernel(y = y, X = X, Zlist = list(Z, W, V), Klist = list(A, E, GE),
                               varbetahat = T, varuhat = T)

# Pull out estimates and predictions
beta <- fit_EgxE$betahat

rand <- fit_EgxE$uhat %>% 
  data.frame(line_name = names(.), value = ., row.names = NULL, stringsAsFactors = FALSE) %>%
  mutate(kernel = str_extract(line_name, pattern = "K_[0-9]"))

g <- rand %>%
  filter(kernel == "K_1") %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", ""))

e <- rand %>%
  filter(kernel == "K_2") %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  rename(environment = line_name)

ge <- rand %>%
  filter(kernel == "K_3") %>% 
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  separate(col = line_name, into = c("line_name", "environment"), sep = ":") %>%
  mutate(line_name = str_replace(line_name, "line_name", ""),
         environment = str_replace(environment, "environment", ""))

# Combine main effects and GxE
g_vp <- full_join(g, ge, by = "line_name") %>%
  filter(line_name %in% vp) %>%
  select(-starts_with("kernel")) %>%
  rename(g_0 = value.x, g_1 = value.y) %>%
  mutate(pred = g_0 + g_1) %>%
  select(line_name, environment, g_0, g_1, pred) %>%
  arrange(environment, line_name)


EgxE_acc <- full_join(g_vp, pheno_vp_nospread, by = c("line_name", "environment")) %>% 
  group_by(environment) %>%
  do(as.data.frame(boot_cor(.$pred, .$value, 1000)))


```


### Environmental Covariables

Now we will look at models that incorporate environmental covariables. This essentially allows data to be shared across environments, in the same way that data is shared across genotypes. When data is shared across genotypes, we can predict the value of unobserved genotypes. Similarly, sharing data across environments should allow us to predict unobserved environments.


#### Main Effects Model 

The model here is similar to Equation 1, except the main effects of environments are predicted by environmental covariables.

Equation 6:
$$
y_{ij} = \mu + g_i + e_j + \epsilon_{ij}
$$


where $y_{ij}$ is the phenotypic observation of the $i$th genotype in the $j$th environment, $\mu$ is the grand mean (fixed), $g_i$ is the fixed effect of the $i$th genotype, $e_j$ is the random effect of the $j$th environment, and $\epsilon_{ij}$ is the randome error term associated with the $i$th genotype in the $j$th environment. In mixed model form, this equation can be re-written as

Equation 7 (same as Equation 3):
$$
y = X\beta + Zg + We + \epsilon
$$

where $X$ is a design matrix of 1s, $\beta$ is a vector of fixed effects (means), $Z$ is a design matrix of that relates the phenotypic observations to the random genotypic effects, $g$ is a vector of genotype effects, $W$ is a design matrix relating the phenotypic observations to the random environmental effects, and $e$ is a vector of environmental effects.

$g$ is assumed to be a random variable such that $g \sim N(0, G \sigma^2_g)$, where $G$ is the genomic relationship matrix, and $e$ is assumed to be a random variable such that $e_j \sim N(0, \Omega \sigma^2_e)$, where $\Omega$ is a covariance matrix between environments.


In R code form

```{r main.eff.EC}

# Define the X matrix
X <- matrix(1, nrow = nrow(y))

# Define the Z matrix
Z <- model.matrix(~ -1 + line_name, data = pheno_tp)

# Define the W matrix
W <- model.matrix(~ -1 + environment, data = pheno_tp)
# Define the covariance structure of this matrix (diag)
envs <- as.character(unique(pheno_tp$environment))
E <- O[envs, envs]

# Solve the mixed model
fit_eg <- emmremlMultiKernel(y = y, X = X, Zlist = list(Z, W), Klist = list(A, E), varbetahat = T, varuhat = T)

# Pull out estimates and predictions
beta <- fit_Eg_rand$betahat

rand <- fit_eg$uhat %>% 
  data.frame(line_name = names(.), value = ., row.names = NULL, stringsAsFactors = FALSE) %>%
  mutate(kernel = str_extract(line_name, pattern = "K_[0-9]"))

g <- rand %>%
  filter(kernel == "K_1") %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  rename(pred = value)

e <- rand %>%
  filter(kernel == "K_2") %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  rename(environment = line_name)

# Accuracy of the VP
g_vp <- g %>% 
  filter(line_name %in% vp)

eg_acc <- full_join(g_vp, pheno_vp_nospread, by = c("line_name")) %>% 
  group_by(environment) %>%
  do(as.data.frame(boot_cor(.$pred, .$value, 1000)))


```



#### Main Effects and Interaction Model 1 (Eg x E)

This model expands Equation 6 to include an interaction term between the random genotypic effects (informed by markers) and the environmental effects (informed by environmental covariables).

Equation 8:
$$
y_{ij} = \mu + g_i + e_j + ge_{ij} + \epsilon_{ij}
$$

where $ge_{ij}$ is the random interaction effect of the $i$th genotype in the $j$th environment. In mixed model equation form, Equation 8 is written

Equation 9 (same as equation 5):
$$
y = X\beta + Zg + We + Vge + \epsilon
$$

where $V$ is a design matrix of random interaction effects and $ge$ is a vector of genotype-environment interaction effects.

$g$ is assumed to be a random variable such that $g \sim N(0, G \sigma^2_g)$, where $G$ is the genomic relationship matrix, $e$ is assumed to be a random variable such that $e_j \sim N(0, \Omega \sigma^2_e)$, where $\Omega$ is a covariance matrix between environments, and $ge$ is assumed to be a random variable such that $ge \sim N(0, \Sigma  \sigma^2_{ge})$, where $\Sigma$ defines the covariance structure of the $ge$ effects and takes the form  $\Sigma = [Z_g G Z'_g] \cdot [W_e \Omega W'_e]$, with $\cdot$ indicating the Hadamard product.

In R code form


```{r main.eff.inter.EC}

# Define the X matrix
X <- matrix(1, nrow = nrow(y))

# Define the Z matrix
Z <- model.matrix(~ -1 + line_name, data = pheno_tp)

# Define the W matrix
W <- model.matrix(~ -1 + environment, data = pheno_tp)
# Define the covariance structure of this matrix
envs <- as.character(unique(pheno_tp$environment))
E <- O[envs, envs]

# Define the V matrix
V <- model.matrix(~ -1 + line_name:environment, data = pheno_tp)

# Define the covariance structure of this matrix
## Incidence matrix of all lines
Z_all <- model.matrix(~ -1 + line_name, data = pheno_use)
## Incidence matrix of all environments
W_all <- model.matrix(~ -1 + environment, data = pheno_use)

G_cov <- Z_all %*% A %*% t(Z_all)
E_cov <- W_all %*% E %*% t(W_all)
GE <- matrixcalc::hadamard.prod(G_cov, E_cov) %>%
  structure(dimnames = list(colnames(V), colnames(V)))

# Solve the mixed model
fit_egxE <- emmremlMultiKernel(y = y, X = X, Zlist = list(Z, W, V), Klist = list(A, E, GE),
                               varbetahat = T, varuhat = T)

# Pull out estimates and predictions
beta <- fit_egxE$betahat

rand <- fit_egxE$uhat %>% 
  data.frame(line_name = names(.), value = ., row.names = NULL, stringsAsFactors = FALSE) %>%
  mutate(kernel = str_extract(line_name, pattern = "K_[0-9]"))

g <- rand %>%
  filter(kernel == "K_1") %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", ""))

e <- rand %>%
  filter(kernel == "K_2") %>%
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  rename(environment = line_name)

ge <- rand %>%
  filter(kernel == "K_3") %>% 
  mutate(line_name = str_replace(line_name, "K_[0-9]", "")) %>%
  separate(col = line_name, into = c("line_name", "environment"), sep = ":") %>%
  mutate(line_name = str_replace(line_name, "line_name", ""),
         environment = str_replace(environment, "environment", ""))

# Combine main effects and GxE
g_vp <- full_join(g, ge, by = "line_name") %>%
  filter(line_name %in% vp) %>%
  select(-starts_with("kernel")) %>%
  rename(g_0 = value.x, g_1 = value.y) %>%
  mutate(pred = g_0 + g_1) %>%
  select(line_name, environment, g_0, g_1, pred) %>%
  arrange(environment, line_name)


egxe_acc <- full_join(g_vp, pheno_vp_nospread, by = c("line_name", "environment")) %>% 
  group_by(environment) %>%
  do(as.data.frame(boot_cor(.$pred, .$value, 1000)))


```





## Sandbox


Attempts from @Lado2016a

```{r}

# Define the X matrix
X <- matrix(1, nrow = nrow(y))

# Define the Z matrix
Z <- model.matrix(~ -1 + line_name:environment, data = pheno_tp)

# Create the random effect covariance matrix
Sig <- kronecker(Sig_E_chk, A, make.dimnames = TRUE)

# Fit the model
fit <- mixed.solve(y = y, Z = Z, X = X, K = Sig, method = "REML")

# Pull out estimates and predictions
beta <- fit$beta

rand <- fit$u %>% 
  data.frame(line_name = names(.), pred = ., row.names = NULL, stringsAsFactors = FALSE) %>%
  separate(line_name, into = c("environment", "line_name"), sep = ":")

# Get the vp
u_vp <- rand %>% 
  filter(line_name %in% vp)

full_join(u_vp, pheno_vp_use, by = c("line_name", "environment")) %>% 
  group_by(environment) %>% 
  summarize(r_MG = cor(pred, value, use = "complete.obs"))




```




## Matrix Construction

```{r}

# Rename the E matrix
dimnames(E) <- dimnames(E) %>% 
  lapply(str_replace, pattern = "16", replacement = "_2016")

# Filter the genotype matrix
M <- s2_imputed_mat[c(tp, vp),]

# Calculate the additive relationship matrix
A <- A.mat(M, min.MAF = 0, max.missing = 1)


# Create the GXE matrix by taking the kronecker product of the environment matrix and the additive relationship matrix
GE <- kronecker(A, E, make.dimnames = T)


```


## Model Breakdown

Here is a description of the models that will be tested.

#### Basic Quantitative Genetics Model

The basic fitted model for a quantitative trait might be

$$ y_{ij} = \mu + g_{i} + t_{j} + (gt)_{ij} + \epsilon_{ij} $$

#### Basic Mixed Model

The regular mixed model takes the form
$$ y = X \beta + Zu + \epsilon $$

where $X$ is the incidence matrix of fixed effects, $\beta$ is the vector of fixed effects, $Z$ is the incidence matrix of random effects, $u$ is the vector of random effects, and $\epsilon$ is the vector of residuals.


$u$ is assumed to follow $u_i \sim MVN(0, A \sigma^2_u)$$

$\epsilon$ is assumed to follow $\epsilon_i \sim MVN(0, R \sigma^2_\epsilon)$


For the RR-BLUP model, $A$ is an identity matrix, while $Z$ is the marker matrix and $u$ are the marker effects. For the GBLUB model, $A$ is the realized genomic relationshop matrix, while $Z$ is an incidence matrix for genotypes and $u$ are the breeding values.


With no fixed effects, we can turn $X \beta$ into a general intercept $\mu$

In the G-BLUP model, we can turn $Zu$ into $G$


#### Basic G-BLUP Model - One Environment

For the normal G-BLUP model for genomic prediction in a single environment, the model takes the form:

$$ y_{i} = \mu + G_{i} + \epsilon_i $$

where $y_i$ is the phenotypic observation of the $i$th genotype, $\mu$ is the grand mean, $G_i$ is the genotypic random effect of genotype $i$, and $\epsilon_i$ is the residual effect of genotype $i$. 


$G$ is assumed to follow $G_i \sim MVN(0, \Sigma \sigma^2_u)$, where $Sigma$ is the Kronecker product of the realized genomic relationship matrix, $A$, and environmental relationship matrix $E$. In one environment, $E$ is scalar 1.

$\epsilon$ is assumed to follow $\epsilon_i \sim MVN(0, R \sigma^2_\epsilon)$, where R is an identity matrix where homoscedasticity is assumed.


Here is an example of that calculation using real data:

```{r, results='markup'}
# Environment
env <- "STP_2016"

# Subset the phenos for modelling
pheno_model <- pheno %>% 
  filter(environment %in% env, trait == "GrainYield") %>%
  select(line_name, environment, value) %>%
  # Dummy variable for training or validation
  mutate(population = ifelse(line_name %in% tp, "tp", "vp")) %>%
  # Sort on environment, then genotype
  arrange(line_name, environment)

# Training phenotypes
y <- pheno_model %>% 
  filter(population == "tp") %>%
  unite(observation, line_name, environment, sep = ":", remove = T) %>%
  # Code to remove existing rownames then add back in
  rownames_to_column() %>%
  select(-rowname, -population) %>%
  column_to_rownames("observation") %>% 
  as.matrix()

# validation phenos
y_test <- pheno_model %>% 
  filter(population == "vp") %>%
  unite(observation, line_name, environment, sep = ":", remove = T) %>%
  # Code to remove existing rownames then add back in
  rownames_to_column() %>%
  select(-rowname, -population) %>%
  column_to_rownames("observation") %>% 
  as.matrix()



# X matrix - there are no fixed effects, just grand mean
X <- matrix(1, nrow = nrow(y), ncol = 1)

# Z matrix relates the phenotypic observations in y to the random genotypic effects u
Z <- diag(nrow(y))
Z <- cbind(Z, matrix(0, nrow = nrow(y), ncol = nrow(y_test)))
dimnames(Z) <- list(tp, c(tp, vp))

# The sigma matrix is the kronecker product of the Sigma_G matrix (or A matrix) and the Sigma_E matrix (or scalar 1)
Sig_G <- A
Sig_E <- matrix(1, nrow = 1, ncol = 1, dimnames = list(env, env))

Sig <- kronecker(Sig_G, Sig_E, make.dimnames = T)

# solve the mixed model
fit <- mixed.solve(y = y, Z = Z, K = Sig, X = X, method = "REML")

vp_obs <- str_c(vp, env, sep = ":")

# Accuracy
c(r_MG = cor(fit$u[vp_obs], y_test))

```




#### G-BLUP Model - Multiple Fixed Environments

For a G-BLUP model for multiple environments, the model takes a similar form. Assume there are $I$ genotypes in $J$ environments.

$$ y_{ij} = \mu_j + G_{ij} + \epsilon_{ij} $$

where $y_ij$ is the phenotypic observation of the genotype $i$ in environment $j$ , $\mu{j}$ is the mean of environment $j$, $G_{ij}$ is the random effect of genotype $i$ in environment $j$, and $\epsilon_{ij}$ is the residual effect of genotype $i$ in environment $j$.


$G$ is assumed to follow $G_i \sim MVN(0, \Sigma \sigma^2_u)$, where $Sigma$ is the Kronecker product of the realized genomic relationship matrix, $A$, and environmental relationship matrix $E$. We can allow for genetic effects to vary depending on the evironment by estimating $\sigma^2_u$ for each environment.44

$\epsilon$ is assumed to follow $\epsilon_i \sim MVN(0, R \sigma^2_\epsilon)$, where R is an identity matrix where homoscedasticity is assumed.


Here is an example of that calculation using real data:

```{r, results='markup'}

# Environment
env <- c("STP_2016", "CRM_2016")

# Subset the phenos for modelling
pheno_model <- pheno %>% 
  filter(environment %in% env, trait == "GrainYield") %>%
  select(line_name, environment, value) %>%
  # Dummy variable for training or validation
  mutate(population = ifelse(line_name %in% tp, "tp", "vp")) %>%
  # Sort on environment, then genotype
  arrange(line_name, environment)

# Training phenotypes
y <- pheno_model %>% 
  select(-population) %>% 
  spread(environment, value) %>% 
  rownames_to_column() %>% 
  select(-rowname) %>% 
  column_to_rownames("line_name") %>% 
  as.matrix()

## Create matrices

# X matrix
X <- matrix(1, nrow = nrow(y), ncol = 1)

# Data for Z matrix
Z <- diag(1, length(tp), nrow(y))


# The sigma matrix is the kronecker product of the Sigma_G matrix (or A matrix) and the Sigma_E matrix (or scalar 1)
Sig_G <- A
Sig_E <- diag(length(env))
dimnames(Sig_E) <- list(sort(env), sort(env))

Sig <- kronecker(Sig_G, Sig_E, make.dimnames = T)

y_use <- y
y_use[vp,] <- NA

## Start with MTM to run an example
## MTM is for multiple traits, so if we consider phenotypes in different environments as genetically
## correlated traits (Falconer), then this will be suitable
fit_MTM <- MTM(Y = y_use, K = list(list(K = A, COV = list(type = "UN", df0 = 2, S0 = diag(2)))),
               resCov = list(type = "DIAG", df0 = rep(1, 2), S0 = rep(1, 2)),
               nIter = 100, burnIn = 50
)

mtm_acc <- sapply(X = seq(ncol(y)), FUN = function(i) {
  vp_hat <- fit_MTM$YHat[vp,i]
  y_vp <- y[vp,i]
  cor(vp_hat, y_vp) })



# Now try with the multivariate function in EMMREML to allow the genetic variance to vary
## across environments

# We have to transpose some matrices
y_t <- t(y)
y_use <- y_t %*% t(Z)

Z_use <- t(Z)

X_use <- t(X) %*% t(Z)


fit_emm <- emmremlMultivariate(Y = y_use, X = X_use, Z = Z_use, K = Sig_G, 
                               tolpar=1e-6,varBhat=FALSE, varGhat=FALSE, PEVGhat=FALSE, 
                               test=FALSE)

# Check accuracy
emm_acc <- sapply(X = seq(ncol(y)), FUN = function(i) {
  vp_hat <- fit_emm$Gpred[i,vp]
  y_vp <- y[vp,i]
  cor(vp_hat, y_vp) })












# Data for X matrix
X_data <- droplevels(filter(pheno_model, population == "tp"))
# The X matrix will relate each observation to the fixed effects, in this case environments
X <- model.matrix(~ environment, data = X_data)

# Data for Z matrix
Z_data <- droplevels(filter(pheno_model, environment %in% env)) %>%
  filter(population == "tp")
# Z matrix relates the phenotypic observations in y to the random genotypic effects u
Z <- model.matrix(~ -1 + line_name:environment, data = Z_data)

# The sigma matrix is the kronecker product of the Sigma_G matrix (or A matrix) and the Sigma_E matrix (or scalar 1)
Sig_G <- A
Sig_E <- diag(length(env))
dimnames(Sig_E) <- list(sort(env), sort(env))

Sig <- kronecker(Sig_G, Sig_E, make.dimnames = T)

# solve the mixed model
fit <- mixed.solve(y = y, Z = Z, K = Sig, X = X, method = "REML")

# TP_observations
tp_obs <- str_c(tp, env[1], sep = ":")

# VP observations
vp_obs <- str_c(vp, env[1], sep = ":")

# Accuracy
cor(y_test[vp_obs,], fit$u[vp_obs])

```


```{r, results='markup'}

# Prediction environment
pred_env <- "STP_2016"
# Validation environment
val_env <- "CRM_2016"

# Subset the phenos for modelling
pheno_model <- pheno %>% 
  filter(environment %in% c(pred_env, val_env), trait == "GrainYield") %>%
  select(line_name, environment, value) %>%
  # Dummy variable for training or validation
  mutate(population = ifelse(line_name %in% tp, "tp", "vp")) %>%
  # Sort on environment, then genotype
  arrange(line_name, environment)

# Training phenotypes
y <- pheno_model %>% 
  filter(population == "tp", environment %in% pred_env) %>%
  unite(observation, line_name, environment, sep = ":", remove = T) %>%
  # Code to remove existing rownames then add back in
  rownames_to_column() %>%
  select(-rowname, -population) %>%
  column_to_rownames("observation") %>% 
  as.matrix()

# validation phenos
y_test <- pheno_model %>% 
  filter(population == "vp", environment %in% val_env) %>%
  unite(observation, line_name, environment, sep = ":", remove = T) %>%
  # Code to remove existing rownames then add back in
  rownames_to_column() %>%
  select(-rowname, -population) %>%
  column_to_rownames("observation") %>% 
  as.matrix()

# Data for X matrix
# X_data <- droplevels(filter(pheno_model, population == "tp", environment %in% pred_env))
# # The X matrix will relate each observation to the fixed effects, in this case environments
# X <- model.matrix(~ environment, data = X_data)

# Vector of 1s for the X matrix
X <- matrix(1, nrow = length(y))

# Data for Z matrix
Z_data <- droplevels(filter(pheno_model)) %>%
  filter(population == "tp", environment %in% pred_env)
# Z matrix relates the phenotypic observations in y to the random genotypic effects u
Z <- model.matrix(~ -1 + line_name:environment, data = Z_data)

# The sigma matrix is the kronecker product of the Sigma_G matrix (or A matrix) and the Sigma_E matrix (or scalar 1)
Sig_G <- A

# Covariance matrix of environments
Sig_E <- matrix(1, nrow = length(c(pred_env, val_env)), ncol = length(c(pred_env, val_env)))
dimnames(Sig_E) <- list(c(pred_env, val_env), c(pred_env, val_env))

Sig <- kronecker(Sig_E, Sig_G)
dimnames(Sig) <- list(c(str_c(row.names(Sig_G), pred_env, sep = ":"), str_c(row.names(Sig_G), val_env, sep = ":")),
                      c(str_c(row.names(Sig_G), pred_env, sep = ":"), str_c(row.names(Sig_G), val_env, sep = ":")))

# solve the mixed model
fit <- mixed.solve(y = y, Z = Z, K = Sig, X = X, method = "REML")

# VP observations
vp_obs <- str_c(vp, val_env, sep = ":")

# Accuracy
cor(y_test[vp_obs,], fit$u[vp_obs])

```




## Predictions

Predictions will be made by training on one environment, using the kronecker product of the relationship matrix and the environmental covariance matrix, and then validating in another environment. This will be compared to simply training the model in one environment and validating predictions in another environment

```{r}

# Find environments in which the tp was grown
TP_env <- pheno %>% 
  filter(line_name %in% tp) %>% 
  distinct(environment) %>%
  unlist()

# Find environment in which the C1R was grown
VP_env <- pheno %>%
  filter(line_name %in% vp) %>%
  distinct(environment) %>%
  unlist()

```









### Model 1 - Fixed Effect of Environment



```{r}


### TEST
tp_env <- TP_env[1]
vp_env <- VP_env[2]

sel_trait <- "GrainYield"

# training phenos
y <- pheno %>% 
  filter(environment == tp_env, line_name %in% tp, trait == sel_trait) %>%
  select(line_name, value) %>% 
  column_to_rownames("line_name") %>% 
  as.matrix()

# validation phenos
y_test <- pheno %>% 
  filter(environment == vp_env, line_name %in% vp, trait == sel_trait) %>%
  select(line_name, value) %>% 
  column_to_rownames("line_name") %>% 
  as.matrix()


### Normal GBLUP prediction

# Model matrix for random effects
Z <- diag(length(y))
Z <- cbind(Z, matrix(0, nrow = length(y), ncol = length(y_test)))

# Fit the model
solve_out <- mixed.solve(y = y, Z = Z, K = A, method = "REML")

# Accuracy
cor(solve_out$u[vp], y_test)

```

## Testing

```{r}



## Model matrices for GxE

# Create the covariance matrix for the training environment versus testing environment
E_sub <- E[c(tp_env, vp_env), c(tp_env, vp_env)]

# Create the kronecker product matrix
GE_sub <- kronecker(A, E_sub, make.dimnames = T)

# Combine observed training genotype names with observed environment
tp_obs <- str_c(tp, tp_env, sep = ":")

# Combine desired validation genotype names with desired environment
vp_obs <- str_c(vp, vp_env, sep = ":")

Z <- matrix(0, nrow = length(y), ncol = ncol(GE_sub), 
            dimnames = list(tp_obs, colnames(GE_sub)))

# Add 1s
Z[cbind(match(tp_obs, row.names(Z)), match(tp_obs, colnames(Z)))] <- 1


# Fit the model
solve_out_GE <- mixed.solve(y = y, Z = Z, K = GE_sub, method = "REML")

# Accuracy
cor(solve_out_GE$u[vp_obs], y_test)



## Create an expanded grid of genotype and environment combinations
ge_combo <- pheno %>% 
  select(line_name, environment)

dd <- data.frame(a = gl(3,4), b = gl(4,1,12)) # balanced 2-way



options("contrasts")


model.matrix(~ a + b, dd)
model.matrix(~ a + b, dd, contrasts = list(a = "contr.sum"))
model.matrix(~ a + b, dd, contrasts = list(a = "contr.sum", b = "contr.poly"))
m.orth <- model.matrix(~a+b, dd, contrasts = list(a = "contr.helmert"))



# Iterate over the tp environments










## Notes from Malosetti, 2016





```

