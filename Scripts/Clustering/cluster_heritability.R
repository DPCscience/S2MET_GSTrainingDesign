## Use environmental clusters to calculate heritability
## 
## Author: Jeff Neyhart
## Last modified: March 27, 2018
## 
## This script will perform different clustering procedures on the S2MET data
## and calculate the within and across-cluster heritabilities.
## 


### Run for MSI

# Run the source script
repo_dir <- "/panfs/roc/groups/6/smithkp/neyha001/Genomic_Selection/S2MET/"
source(file.path(repo_dir, "source.R"))


## Load packages
packages <- c("lme4")
invisible(lapply(packages, library, character.only = TRUE, lib.loc = package_dir))


### Run for local machine

# # Run the source script
# repo_dir <- getwd()
# source(file.path(repo_dir, "source.R"))
# 
# # Load packages and the source script
# library(lme4)


# Load the clustering results
load(file.path(result_dir, "distance_methods_results.RData"))


## Number of cores
n_core <- ifelse(Sys.info()["sysname"] == "Windows", 1, detectCores())


# Tidy the the distance matrix data.frame, then combine the data.frames for
# TP and TP + VP
dist_method_df_all_tidy <- dist_method_df_all %>% 
  mutate(population = "all") %>% 
  gather(dist_method, dist, -trait, -population)

# For each trait, identify the most common set of environments
dist_method_df_common_env <- dist_method_df_all_tidy %>% 
  group_by(trait) %>% 
  summarize(common_env = list(map(dist, ~row.names(as.matrix(.))) %>% reduce(intersect)))

# Combine with the distance metrics, convert to a matrix, subset the environments,
# then convert back to a dist object
# Then create cluster objects
clust_method_df_all <- full_join(dist_method_df_all_tidy, dist_method_df_common_env, by = "trait") %>% 
  mutate(dist = list(dist, common_env) %>% pmap(~subset_env(dist = .x, envs = .y)),
         cluster = map(dist, hclust)) %>%
  select(-common_env)


# Just the TP
dist_method_df_tp_tidy <- dist_method_df_tp %>% 
  mutate(population = "tp") %>% 
  gather(dist_method, dist, -trait, -population)

# For each trait, identify the most common set of environments
dist_method_df_common_env <- dist_method_df_tp_tidy %>% 
  group_by(trait) %>% 
  summarize(common_env = list(map(dist, ~row.names(as.matrix(.))) %>% reduce(intersect)))

# Combine with the distance metrics, convert to a matrix, subset the environments,
# then convert back to a dist object
# Then create cluster objects
clust_method_df_tp <- full_join(dist_method_df_tp_tidy, dist_method_df_common_env, by = "trait") %>% 
  mutate(dist = list(dist, common_env) %>% pmap(~subset_env(dist = .x, envs = .y)),
         cluster = map(dist, hclust)) %>%
  select(-common_env)


# What should be the minimum and maximum number of clusters?
min_k <- 2
max_k <- 10
seq_k <- seq(min_k, max_k)


## Combine the data.frames
## Replicate the clusters and add each cluster k from min_k to max_k
clust_method_df <- bind_rows(clust_method_df_all, clust_method_df_tp) %>%
  rerun(.n = length(seq_k), .) %>%
  list(., seq_k) %>% 
  pmap_df(~mutate(.x, k = .y))


## Using the value of k, cut the cluster tree and create data.frames for the environment
## and the assigned cluster
clust_method_df_tomodel <- clust_method_df %>% 
  mutate(env_cluster = list(cluster, k) %>% 
           pmap(~cutree(tree = .x, k = .y) %>% 
                  data.frame(environment = names(.), cluster = ., stringsAsFactors = FALSE)) )

# List of models
# forms <- formulas(~ value,
#                   no_gc = ~ (1 | line_name) + (1|environment) + (1|line_name:environment) + 
#                     (1|line_name:environment:cluster),
#                   full = ~ (1 | line_name) + environment + (1|line_name:environment) + 
#                     (1|line_name:environment:cluster) + (1|line_name:cluster) )


# Breakup by core
clust_method_df_tomodel_core <- clust_method_df_tomodel %>% 
  assign_cores(n_core) %>%
  split(.$core)

## Parallelize over the core df
cluster_method_herit_out <- mclapply(X = clust_method_df_tomodel_core, FUN = function(core_df) {
  
  # Create a list to store the results
  results_list <- vector("list", nrow(core_df))
  
  # Iterate over the list
  for (i in seq_along(results_list)) {
    
    df <- unnest(core_df[i,], env_cluster)
    
    # Combine the phenotypic data
    pheno_cluster <- left_join(df, S2_MET_BLUEs, by = c("trait", "environment"))
    
    # Filter all data or the tp, depending on the population
    if (unique(df$population) == "tp") {
      pheno_tomodel <- pheno_cluster %>%
        filter(line_name %in% tp)
      
    } else {
      pheno_tomodel <- pheno_cluster
      
    }
    
    # Extract the weights
    wts <- pheno_tomodel$std_error^2
    
    # lmer control
    lmer_control <- lmerControl(check.nobs.vs.nlev = "ignore", check.nobs.vs.nRE = "ignore",
                                calc.derivs = FALSE)
    
    # Main formula
    form <- value ~ (1 | line_name) + (1|location) + (1|year) + (1|line_name:location) + 
      (1|line_name:year) + (1|line_name:location:cluster) + (1|line_name:year:cluster) + 
      (1|line_name:cluster) + (1|line_name:location:year:cluster)    
    
    
    # Fit the model
    fit <- lmer(formula = form, data = pheno_tomodel, control = lmer_control, weights = wts)
    
    # Calculate heritability
    herit_df <- cluster_heritability(object = fit, breakup_env = TRUE)
    
    # Return the variance components
    var_comp <- as.data.frame(VarCorr(fit)) %>%
      select(source = grp, variance = vcov)
    
    # Return a list
    results_list[[i]] <- list(herit = herit_df, var_comp = var_comp)
    
  }
  
  # Add the list to the core_df and return
  core_df %>%
    select(trait:dist_method, k) %>%
    mutate(out = results_list)
  
}, mc.cores = n_core)
    


save_file <- file.path(result_dir, "cluster_heritability_results.RData")
save("cluster_method_herit_out", file = save_file)





