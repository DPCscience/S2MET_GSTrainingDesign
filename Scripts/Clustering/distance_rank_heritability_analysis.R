## Heritability based on environmental distance - analysis
## 
## Author: Jeff Neyhart
## Last Updated: October 9, 2018
## 
## This script will look at prediction accuracies from adding environments after
## ranking based on specific distance metrics
## 
## 



## Run on a local machine
repo_dir <- getwd()
source(file.path(repo_dir, "source.R"))

# Significance level
alpha <- 0.05


# Read in the results
load(file.path(result_dir, "cluster_heritability_tp_TESTING.RData"))
# load(file.path(result_dir, "cluster_heritability_tp.RData"))


# Get the unique distance models, then assign new names
models <- sort(unique(subset(cluster_herit_out, !str_detect(model, "sample"), model, drop = T))) 
models_rename <- setNames(c("GCD", "MYEC_All", "MYEC_Cor1", "MYEC_F1", "MYEC_Cor5", "MYEC_F5", "OYEC_All", "OYEC_Cor1", "OYEC_F1", "OYEC_Cor5", "OYEC_F5", "PD"), models) %>%
  # Order
  .[c(length(.), seq(length(.) - 1))] %>%
  c(., "random" = "Random")

# Vector of colors
colors1 <- umn_palette(3)[-1:-2]
colors2 <- umn_palette(2)[-1:-2]
colors3 <- umn_palette(4)[-1:-2]

colors <- c(umn_palette(2)[1:2], colors1[c(1,6)], colors2[c(1,6)], colors3[1], colors1[c(2,7)], colors2[c(2,7)], colors3[2], "grey75") %>%
  setNames(nm = c(models_rename))


# Summarize the heritability
cluster_herit1 <- cluster_herit_out %>% 
  mutate(out = map(out, ~{data_frame(n_e = seq_along(.) + 1, heritability = map_dbl(., "heritability"))})) %>% 
  unnest()

## First check for normality among the samples



## Summarize the random samples as a baseline
cluster_herit_random <- cluster_herit1 %>%
  filter(str_detect(model, "sample")) %>%
  group_by(trait, n_e) %>% 
  summarize_at(vars(heritability), funs(mean, sd, n())) %>% 
  mutate(se = sd / sqrt(n), stat = se * qt(p = 1 - (alpha / 2), df = n - 1), 
         lower = mean - stat, upper = mean + stat) %>% 
  select(-se, -stat) %>%
  ungroup() %>%
  mutate(model = "random")

# Subset the non-random models
cluster_herit_model <- cluster_herit1 %>% 
  filter(!str_detect(model, "sample")) %>%
  rename(mean = heritability)



# Plot
cluster_herit_model %>% 
  ggplot(aes(x = n_e, y = mean, color = model, fill = model)) +
  geom_ribbon(data = cluster_herit_random, aes(ymin = lower, ymax = upper), alpha = 0.25, fill = "grey75", color = "grey75") + 
  geom_line(data = cluster_herit_random, color = "grey75") + 
  geom_line() + 
  facet_grid(trait ~ environment, scales = "free_y") +
  # scale_color_manual(values = c("Random" = "grey75"), name = "Model") + 
  # scale_fill_manual(values = c("Random" = "grey75"), name = "Model") + 
  theme_acs()





### Calculate heritability as relative to using all environments
cluster_herit_stand <- cluster_herit1 %>% 
  # filter(n_e < max(cluster_herit1$n_e)) %>%
  group_by(environment, trait, model) %>% 
  mutate(rel_heritability = heritability - heritability[n()])

## Check the distribution to ensure normality



# First average over environments
cluster_herit_stand_summ <- cluster_herit_stand %>% 
  group_by(trait, model, n_e) %>% 
  summarize(herit = mean(rel_heritability)) %>%
  # Summarize over replicates
  ungroup() %>%
  mutate(model = ifelse(str_detect(model, "sample"), "random", model)) %>%
  group_by(trait, model, n_e) %>%
  summarize_at(vars(herit), funs(mean, sd, lower = quantile1(.)[1], upper = quantile1(.)[2], n())) %>% 
  # Use the empirical quantiles to calculate a confidence interval
  mutate_at(vars(lower, upper), funs(ifelse(model == "random", ., NA))) %>%
  # mutate(se = sd / sqrt(n), lower = mean - (se * abs(lower)), upper = mean + (se * abs(upper))) %>%
  mutate(se = sd / sqrt(n), stat = se * qt(1 - (alpha / 2), n - 1), lower = mean - stat, upper = mean + stat) %>%
  ungroup() %>%
  # Rename the models
  mutate(model = factor(str_replace_all(model, models_rename), levels = models_rename))






# Plot
g_cluster_herit_stand <- cluster_herit_stand_summ %>%
  mutate(model1 = model) %>%
  filter(model != "Random") %>%
  ggplot(aes(x = n_e, y = mean, ymin = lower, ymax = upper, color = model, fill = model)) +
  geom_ribbon(data = filter(cluster_herit_stand_summ, model == "Random"), alpha = 0.25) + 
  geom_line() + 
  geom_line(data = filter(cluster_herit_stand_summ, model == "Random")) +
  facet_grid(trait ~ model1, scales = "free_y", switch = "y") +
  scale_color_manual(values = colors, name = "Distance\nmeasure") +
  scale_fill_manual(values = colors, name = "Distance\nmeasure") +
  scale_x_continuous(breaks = pretty) +
  ylab("Relative heritability") +
  xlab("Number of environments") +
  theme_acs()
 
ggsave(filename = "distance_rank_heritability.jpg", plot = g_cluster_herit_stand, path = fig_dir, width = 10, height = 5, dpi = 1000)

cluster_herit_stand_summ %>% 
  filter(trait == trait[1], model == model[1]) %>% 
  ggplot(aes(x = n_e, y = mean)) + 
  geom_point() + 
  geom_smooth(method = "lm", formula = y ~ poly(x, 2))

## Fit models
cluster_herit_stand_models <- cluster_herit_stand_summ %>% 
  group_by(trait, model) %>% 
  do({
    fit_linear <- lm(mean ~ n_e, data = .)
    fit_poly <- lm(mean ~ poly(n_e, 2), data = .)
    data_frame(type = c("linear", "polynomial"), fit = list(fit_linear, fit_poly))
  }) %>%
  # Extract r.squared and AIC
  ungroup() %>% 
  mutate(r_squared = map_dbl(fit, ~summary(.)$r.squared), AIC = map_dbl(fit, AIC))

## Plot models
g_cluster_herit_stand_smooth <- cluster_herit_stand_summ %>%
  mutate(model1 = model) %>%
  filter(model != "Random") %>%
  ggplot(aes(x = n_e, y = mean, ymin = lower, ymax = upper, color = model, fill = model)) +
  geom_smooth(data = filter(cluster_herit_stand_summ, model == "Random"), method = "lm", formula = y ~ poly(x, 2), lwd = 0.5) + 
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), se = FALSE, lwd = 0.5) + 
  geom_point(size = 0.5) +
  facet_grid(trait ~ model1, scales = "free_y", switch = "y") +
  scale_color_manual(values = colors, name = "Distance\nmeasure") +
  scale_fill_manual(values = colors, name = "Distance\nmeasure") +
  scale_x_continuous(breaks = pretty) +
  ylab("Relative heritability") +
  xlab("Number of environments") +
  theme_acs()

ggsave(filename = "distance_rank_heritability_smooth.jpg", plot = g_cluster_herit_stand_smooth, path = fig_dir, width = 10, height = 5, dpi = 1000)








## What models outperform random?
cluster_herit_stand_compare <- cluster_herit_stand_summ %>%
  filter(model != "Random") %>% 
  left_join(., filter(cluster_herit_stand_summ, model == "Random"), c("trait", "n_e")) %>% 
  select(trait, model = model.x, n_e, mean = mean.x, random_mean = mean.y, lower = lower.y, upper = upper.y)

# For each model and trait, what is the lower n_e value that is significantly different than random?
cluster_herit_stand_compare_model <- cluster_herit_stand_compare %>% 
  filter(mean != 0, mean >= upper) %>% 
  group_by(trait, model) %>% 
  filter(n_e == min(n_e))

cluster_herit_stand_compare_model %>%
  arrange(trait, n_e) %>%
  as.data.frame()

# Of the models that are better than random early-on, which are common to all traits?
common_models <- cluster_herit_stand_compare_model %>% 
  ungroup() %>% 
  filter(n_e <= 5) %>% 
  split(.$trait) %>% 
  map("model") %>%
  reduce(intersect) %>%
  # Make sure pheno dist and GCD are included
  union(., c("GCD", "PD", "Random"))

  
g_cluster_herit_stand_subset <- cluster_herit_stand_summ %>%
  mutate(model1 = model) %>%
  filter(model %in% common_models, str_detect(model, "EC")) %>%
  ggplot(aes(x = n_e, y = mean, ymin = lower, ymax = upper, color = model, fill = model)) +
  geom_line() + 
  geom_line(data = filter(cluster_herit_stand_summ, !str_detect(model, "EC"))) +
  geom_ribbon(data = filter(cluster_herit_stand_summ, !str_detect(model, "EC"))) + 
  facet_grid(trait ~ model1, scales = "free_y", switch = "y") +
  scale_color_manual(values = colors, name = "Distance\nmeasure") +
  scale_fill_manual(values = colors, name = "Distance\nmeasure") +
  scale_x_continuous(breaks = pretty) +
  ylab("Relative heritability") +
  xlab("Number of environments") +
  theme_acs()

ggsave(filename = "distance_rank_heritability_common.jpg", plot = g_cluster_herit_stand_subset, path = fig_dir, width = 5, height = 5, dpi = 1000)





### Analyze the contribution of GxE to total phenotypic variance
cluster_gxe <- cluster_herit_out %>% 
  mutate(out = map(out, ~{data_frame(n_e = seq_along(.) + 1, var_comp = map(., "var_comp"))})) %>% 
  unnest() %>%
  unnest() %>%
  filter(source != "environment") %>%
  group_by(environment, trait, model, n_e) %>%
  mutate(variance = variance / sum(variance)) %>%
  filter(str_detect(source, "line_name")) %>%
  summarize(GxE_to_G = variance[1] / variance[2])
  


## Summarize the random samples as a baseline
cluster_gxe_random <- cluster_gxe %>%
  filter(str_detect(model, "sample")) %>%
  group_by(trait, n_e) %>% 
  summarize_at(vars(GxE_to_G), funs(mean, sd, n())) %>% 
  mutate(se = sd / sqrt(n), stat = se * qt(p = 1 - (alpha / 2), df = n - 1), 
         lower = mean - stat, upper = mean + stat) %>% 
  select(-se, -stat) %>%
  ungroup() %>%
  mutate(model = "random")

# Subset the non-random models
cluster_gxe_model <- cluster_gxe %>% 
  filter(!str_detect(model, "sample")) %>%
  rename(mean = GxE_to_G)

# Plot
# Just random first
cluster_gxe_random %>%
  filter(n_e != 2) %>%
  ggplot(aes(x = n_e, y = mean, color = model, fill = model, ymin = lower, ymax = upper)) +
  geom_ribbon() + 
  geom_line() + 
  facet_grid(trait ~ ., scales = "free_y")


cluster_gxe_model %>% 
  filter(n_e != 2) %>%
  ggplot(aes(x = n_e, y = mean, color = model, fill = model)) +
  geom_ribbon(data = filter(cluster_gxe_random, n_e != 2), aes(ymin = lower, ymax = upper), alpha = 0.25, fill = "grey75", color = "grey75") + 
  geom_line(data = filter(cluster_gxe_random, n_e != 2), color = "grey75") + 
  geom_line() + 
  facet_grid(trait ~ environment, scales = "free_y") +
  # scale_color_manual(values = c("Random" = "grey75"), name = "Model") + 
  # scale_fill_manual(values = c("Random" = "grey75"), name = "Model") + 
  theme_acs()






### Analyze the sliding window results ###

# Summarize the heritability
cluster_herit_window1 <- cluster_herit_out_window %>% 
  mutate(out = map(out, ~{data_frame(window_number = seq_along(.), heritability = map_dbl(., "heritability"))})) %>% 
  unnest()


## Summarize the random samples as a baseline
cluster_herit_window_random <- cluster_herit_window1 %>%
  filter(str_detect(model, "sample")) %>%
  group_by(trait, window_number) %>% 
  summarize_at(vars(heritability), funs(mean, sd, n())) %>% 
  mutate(se = sd / sqrt(n), stat = se * qt(p = 1 - (alpha / 2), df = n - 1), 
         lower = mean - stat, upper = mean + stat) %>% 
  select(-se, -stat) %>%
  ungroup() %>%
  mutate(model = "random")

# Subset the non-random models
cluster_herit_window_model <- cluster_herit_window1 %>% 
  filter(!str_detect(model, "sample")) %>%
  rename(mean = heritability)



# Plot
cluster_herit_window_model %>% 
  ggplot(aes(x = window_number, y = mean, color = model, fill = model)) +
  geom_ribbon(data = cluster_herit_window_random, aes(ymin = lower, ymax = upper), alpha = 0.25, fill = "grey75", color = "grey75") + 
  geom_line(data = cluster_herit_window_random, color = "grey75") + 
  geom_line() + 
  facet_grid(trait ~ environment, scales = "free_y") +
  # scale_color_manual(values = c("Random" = "grey75"), name = "Model") + 
  # scale_fill_manual(values = c("Random" = "grey75"), name = "Model") + 
  theme_acs()





### Calculate heritability as relative to using all environments
cluster_herit_window_stand <- cluster_herit_window1 %>% 
  left_join(., group_by(cluster_herit1, environment, trait, model) %>% filter(n_e == max(n_e)) %>% rename(max_heritability = heritability)) %>%
  mutate(rel_heritability = heritability - max_heritability)



# First average over environments
cluster_herit_window_stand_summ <- cluster_herit_window_stand %>% 
  group_by(trait, model, window_number) %>% 
  summarize(herit = mean(rel_heritability)) %>%
  # Summarize over replicates
  ungroup() %>%
  mutate(model = ifelse(str_detect(model, "sample"), "random", model)) %>%
  group_by(trait, model, window_number) %>%
  summarize_at(vars(herit), funs(mean, sd, lower = quantile1(.)[1], upper = quantile1(.)[2], n())) %>% 
  # Use the empirical quantiles to calculate a confidence interval
  mutate_at(vars(lower, upper), funs(ifelse(model == "random", ., NA))) %>%
  # mutate(se = sd / sqrt(n), lower = mean - (se * abs(lower)), upper = mean + (se * abs(upper))) %>%
  mutate(se = sd / sqrt(n), stat = se * qt(1 - (alpha / 2), n - 1), lower = mean - stat, upper = mean + stat) %>%
  ungroup() %>%
  # Rename the models
  mutate(model = factor(str_replace_all(model, models_rename), levels = models_rename))




# Plot
g_cluster_herit_window_stand <- cluster_herit_window_stand_summ %>%
  mutate(model1 = model) %>%
  filter(str_detect(model, "EC")) %>%
  ggplot(aes(x = window_number, y = mean, ymin = lower, ymax = upper, color = model, fill = model)) +
  geom_line() + 
  geom_line(data = filter(cluster_herit_window_stand_summ, !str_detect(model, "EC"))) +
  geom_ribbon(data = filter(cluster_herit_window_stand_summ, !str_detect(model, "EC")), alpha = 0.25) + 
  facet_grid(trait ~ model1, scales = "free_y", switch = "y") +
  scale_color_manual(values = colors, name = "Distance\nmeasure") +
  scale_fill_manual(values = colors, name = "Distance\nmeasure") +
  scale_x_continuous(breaks = pretty) +
  ylab("Relative heritability") +
  xlab("Sliding window number") +
  theme_acs()

ggsave(filename = "distance_rank_heritability_window.jpg", plot = g_cluster_herit_window_stand, path = fig_dir, width = 10, height = 5, dpi = 1000)

## Plot using smoothing
g_cluster_herit_window_stand <- cluster_herit_window_stand_summ %>%
  mutate(model1 = model) %>%
  filter(model != "Random") %>%
  ggplot(aes(x = window_number, y = mean, ymin = lower, ymax = upper, color = model, fill = model)) +
  geom_smooth(data = filter(cluster_herit_window_stand_summ, model == "Random"), method = "lm") +
  geom_smooth(method = "lm") + 
  geom_point(size = 1) +
  facet_grid(trait ~ model1, scales = "free_y", switch = "y") +
  scale_color_manual(values = colors, name = "Distance\nmeasure") +
  scale_fill_manual(values = colors, name = "Distance\nmeasure") +
  scale_x_continuous(breaks = pretty) +
  ylab("Relative heritability") +
  xlab("Sliding window number") +
  theme_acs()

ggsave(filename = "distance_rank_heritability_window_smooth.jpg", plot = g_cluster_herit_window_stand, path = fig_dir, width = 10, height = 5, dpi = 1000)


## Fit a model
cluster_herit_window_models <- cluster_herit_window_stand_summ %>% 
  group_by(trait, model) %>%
  do({
    fit <- lm(mean ~ window_number, data = .)
    out <- broom::tidy(fit)
    ci <- `colnames<-`(confint(fit), c("lower", "upper"))
    cbind(out, ci)
  }) %>%
  ungroup() %>%
  mutate(term = ifelse(term == "(Intercept)", "intercept", term))

# Rearrange
cluster_herit_window_models_compare <- cluster_herit_window_models %>%
  filter(model != "Random") %>%
  left_join(cluster_herit_window_models %>% filter(model == "Random") %>% 
              rename_at(vars(estimate, std.error, lower, upper), ~str_c("random_", .)) %>% select(-model, -statistic, -p.value),
            by = c("trait", "term"))

# Filter for models where the intercept is significantly greater than random and the slope is significant and negative
cluster_herit_window_models_intercept <- cluster_herit_window_models_compare %>% 
  filter(term == "intercept") %>% 
  filter(estimate > random_upper) %>%
  select(trait, model)

cluster_herit_window_models_slope <- cluster_herit_window_models_compare %>% 
  filter(term == "window_number") %>% 
  filter(estimate < 0) %>%
  select(trait, model)

# Intersect and find models that were significant for at least 3 traits
intersect(cluster_herit_window_models_intercept, cluster_herit_window_models_slope) %>%
  group_by(model) %>%
  filter(n() >= 3)

# trait           model   
# 1 GrainYield      MYEC_All
# 2 HeadingDate     PD      
# 3 HeadingDate     MYEC_All
# 4 HeadingDateAGDD PD      
# 5 HeadingDateAGDD MYEC_All
# 6 PlantHeight     PD







