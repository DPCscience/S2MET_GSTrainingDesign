---
title: "S2MET Phenotypic Data Summary"
output: html_notebook
---

## Introduction

This notebook will provide some phenotyping data summaries for the S2MET project. It will include:

1. Basic model for g + e + gxe
2. Heritability estimates
3. Correlations among environments

```{r prep}

library(tidyverse)
library(broom)
library(stringr)
library(readxl)
library(pbr)
library(lmerTest)

# Directories
proj_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET/"

pheno_dir <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET/Phenotype_Data/"

# Load the phenotypic data
load(file.path(pheno_dir, "S2_MET_tidy.RData"))
load(file.path(pheno_dir, "S2_MET_BLUE.RData"))

# Load an entry file
entry_file <- "C:/Users/Jeff/Google Drive/Barley Lab/Projects/S2MET/Plant_Materials/S2MET_project_entries.xlsx"

entry_list <- read_excel(entry_file)

# Grab the entry names that are not checks
tp <- entry_list %>% 
  filter(Class == "S2TP") %>% 
  pull(Line)

vp <- entry_list %>% 
  filter(Class == "S2C1R") %>% 
  pull(Line)

# Define the checks
checks <- entry_list %>% 
  filter(Class == "Check") %>% 
  pull(Line)

entries <- entry_list %>% 
  pull(Line)


```


## Basic Summaries

Look at the number of lines per environment

```{r line.summ}

# Filter the phenotypes for all entries minus checks
s2_met_tidy_filt  <- S2_MET_tidy %>% 
  filter(line_name %in% entries) %>%
  mutate_at(vars(-value), parse_guess)


# Count the number of lines per environment
s2_met_tidy_filt %>% 
  group_by(environment, trait) %>% 
  summarize(n = n_distinct(line_name)) %>% 
  spread(trait, n)

```

Find the proportion of unbalance in the dataset

Do this for the TP, then for the VP, then for both

```{r prop.unbal}

s2_met_tidy_count <- s2_met_tidy_filt %>%
  # Add a dummy variables for all observations
  mutate(dummy = 1) %>%
  distinct(trait, line_name, environment, dummy) %>%
  select(trait, line_name, environment, dummy)

# Create count tables for the TP, then the VP
s2_met_tidy_count_tp <- s2_met_tidy_count %>% 
  filter(line_name %in% tp)

s2_met_tidy_count_vp <- s2_met_tidy_count %>% 
  filter(line_name %in% vp)

# Find the proportion of balance
tp_bal <- s2_met_tidy_count_tp %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy)) %>%
  mutate(pop = "tp")

vp_bal <- s2_met_tidy_count_vp %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy))  %>%
  mutate(pop = "vp")

# Intersect the environments with both the TP and VP
common_env <- intersect(
  distinct(s2_met_tidy_count_tp, environment), 
  distinct(s2_met_tidy_count_vp, environment) )

# Filter the larger tidy set on these environments and find the level of balance
common_bal <- s2_met_tidy_count %>% 
  filter(environment %in% common_env$environment) %>% 
  group_by(trait) %>% 
  complete(environment, line_name, fill = list(dummy = 0)) %>% 
  summarize(prop_bal = mean(dummy))  %>%
  mutate(pop = "all")

# Print
list(tp_bal, vp_bal, common_bal) %>% 
  reduce(full_join, by = c("trait", "prop_bal", "pop")) %>% 
  spread(trait, prop_bal)

```


## Heritability

To calculate heritability, we need estimates of $\sigma^2_G$ (the genetic variance), $\sigma^2_{GE}$ (genotype-by-environment interaction variance), and $\sigma^2_R$ (residual variance). 

Since these trials are augmented designs, the estimate of $\sigma^2_G$ will come solely from the lines, and not the checks, while the checks will be used to estimate $\sigma^2_R$. For each trait in each environment, there is some number of lines ($n_g$) and some
number of checks ($n_c$). There are $n$ observations total.

First, we will calculate the hertiability within an environment by fitting the following model per trait and environment:

$$
y_{i} = \mu + G_i + \epsilon_{i}
$$

where $y_{i}$ is the phenotypic observation, $\mu$ is the grand mean, $G_i$ is the the genotypic effect, and $\epsilon_{i}$ is the error associated with the phenotypic observation. $G_i$ is broken down into $g_i + c_i$, where $g_i$ is the random effect of the $i$th genotype, and $c_i$ is the fixed effect of the $i$th check.

The model can be expressed in matrix form as

$$
\mathbf{y = X \beta + Z u + e}
$$

where $y$ is a $n \times 1$ vector of phenotypic observations, $X$ is a $n \times (n_c + 1)$ design matrix of the fixed effects, $\beta$ is a $(n_c + 1) \times 1$ vector of fixed effects, $Z$ is a $n \times n_g$ design matrix of the random effects, $u$ is a $n_g \times 1$ vector of random effects, and $\epsilon$ is a $n \times 1$ vector of residuals.


Second, the heritability will be calcuted for each trait across all environments by fitting the following model:

$$
y_{ij} = \mu + G_i + t_j + (gt)_{ij} + \epsilon_{ij}
$$

where $y_{ij}$ is the phenotypic observation, $\mu$ is the grand mean, $G_i$ is the the genotypic effect (broken down into $g_i + c_i$, where $g_i$ is the random effect of the $i$th genotype, and $c_i$ is the fixed effect of the $i$th check), $t_j$ is the fixed effect of the $j$th environment, $(gt)_{ij}$ is the random effect of the interaction between the $i$th genotype and the $j$th environment, and $\epsilon_{ij}$ is the error associated with the phenotypic observation. There are $n_t$ environments.

The model is expressed in matrix form as

$$
\mathbf{y = X \beta + Z u + W m + e}
$$

where $\mathbf{y}$ is a $n \times 1$ vector of phenotypic observations, $\mathbf{X}$ is a $n \times (n_c + 1)$ design matrix of the fixed effects, $\mathbf{\beta}$ is a $(n_c + 1) \times 1$ vector of fixed effects, $\mathbf{Z}$ is a $n \times n_g$ design matrix of the random genotype effects, $\mathbf{u}$ is a $n_g \times 1$ vector of random genotype effects, $\mathbf{W}$ is a $n \times (n_g * n_t)$ design matrix of the random genotype-environment interaction effects, $\mathbf{m}$ is a $(n_g * n_t) \times 1$ vector of random genotype-environment interaction effects, and $\epsilon$ is a $n \times 1$ vector of residuals.


```{r fit.models}

# Add dummy for the check
s2_met_tidy_model <- S2_MET_tidy %>% 
  filter(line_name %in% entries) %>%
  droplevels() %>%
  mutate(check = ifelse(as.character(line_name) %in% checks, as.character(line_name), "00check"),
         line = ifelse(as.character(line_name) %in% checks, "00line", as.character(line_name))) %>%
  # Group by environments and rescale
  group_by(trait, environment) %>%
  mutate(value_rescale = as.numeric(scale(value))) %>%
  ungroup()

# Fit a model across all environments
s2met_mod_all <- s2_met_tidy_model %>%
  group_by(trait) %>%
  do(mod = lmer(value_rescale ~ (1|line) + check + environment + (1|line:environment), data = .),
     mod2 = lmer(value_rescale ~ (1|line) + check + environment, data = .))
  

```


First test for significance of the $gt$ term using a liklihood ratio test

```{r lrt}
# Perform the liklihood ratio test for GxE
s2met_mod_lrt <- s2met_mod_all %>% 
  group_by(trait) %>%
  do(tidy(anova(.$mod[[1]], .$mod2[[1]])))

s2met_mod_lrt %>% 
  select(trait, p.value) %>% 
  na.omit()
  

```




The broad-sense heritability is calculated on a entry-mean basis according to the formula

$$
H = \frac{ \sigma^2_G }{ \sigma^2_G + \frac{\sigma^2_{GE}}{r} + \frac{\sigma^2_R}{er} }
$$

for overall heritability calculations, and 

$$
H = \frac{ \sigma^2_G }{ \sigma^2_G  + \frac{\sigma^2_R}{r} }
$$


where $e$ is the number of environments and $r$ is the number of replicates. In the case of an augmented design, where the number of replicates is uneven, the following formula is used to calculate the harmonic mean of the number of replications:

$$
p_h = \frac{n}{\sum^n_{i=1} \frac{1}{p_i}}
$$

where $p_h$ is the harmonic mean, $n$ is the number of genotypes, and $p_i$ is the number of replicates of the *i*th genotype.


Here are the estimates of heritability for each trait in each environment


```{r calc.herit.env}

# Calculate a heritability per environment
s2met_herit <- s2_mod %>% 
  mutate(herit = list(herit(mod, geno.term = "line"))) %>%
  ungroup() %>%
  select(-mod) %>%
  unnest()

# Plot
s2met_herit %>%
  filter(Term == "heritability") %>%
  ggplot(aes(x = environment, y = Estimate)) +
  geom_col() +
  facet_grid(trait ~ ., switch = "y") +
  ylab("Heritability") +
  xlab("Environment") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


  
```
  

Now calculate heritability across all environments

```{r calc.herit}

# Calculate a heritability over all environments
s2met_herit_all <- s2met_mod_all %>%
  mutate(herit = list(herit(mod, geno.term = "line", env.term = "environment", 
                            ge.term = "line:environment"))) %>%
  ungroup() %>%
  select(-mod, -mod2) %>%
  unnest()



(herit <- var_comp %>%
  group_by(trait) %>%
  summarize(V_G = V_G, V_GL = V_GL, V_GY = V_GY, V_GLY = V_GLY, V_R = V_R,
            H = V_G / (V_G + (V_GL / l) + (V_GY / y) + (V_GLY / (l * y)) + V_R / (l * y * avg_rep))))



# Plot variance components and heritabilities
herit %>%
  gather(param, value, -trait) %>%
  filter(param != "H") %>%
  ggplot(aes(x = trait, y = value, fill = param)) +
  geom_col(position = "stack") +
  ylab("Value") +
  xlab("Trait") +
  scale_fill_discrete(name = "Variance Component")


```


## Environmental Correlations

Estimate the genetic variance-covariance matrix across environments using the method by @Lado2016a and @Rebonato2000

In this method, a correlation matrix is first calculated using Pearson correlations, then this correlation matrix is decomposed to estimate the genetic correlation.



```{r functions}

# Define a function to correct the correlation matrix
corr_decomp <- function(x) {
  
  # Decomposition
  s <- eigen(x)

  # Set anything less than 0 to 0
  la <- ifelse(s$values <= 0, 0, s$values)

  # Get the eigenvectors
  S <- s$vectors
  
  # Diagonal matrix of eigenvalues
  La <- diag(la)

  B_prime <- S %*% sqrt(La)

  # Normalization matrix
  T_mat <- solve(diag(as.vector(S^2 %*% la)))

  # Return B matrix
  B <- sqrt(T_mat) %*% B_prime * -1
  
  # tcrossprod
  C_prime <- tcrossprod(B)
  dimnames(C_prime) <- dimnames(x)
  return(C_prime)
  
}

```



Calculate the genetic correlation between environments using the training population

```{r env.corr.tp}

# Calculate environmental correlations using all pairwise information on the tp
# First subset the data
pheno_use <- S2.MET.BLUE %>%
  filter(year != 2014)

# Extract tp and correlate
env_cor <- pheno_use %>% 
  filter(line_name %in% tp) %>%
  select(trait, line_name, environment, value) %>%
  # Split by trait
  split(.$trait) %>%
  map(spread, environment, value) %>%
  map(group_by, trait) %>%
  map(function(trait_mat) do(trait_mat, cor_mat = cor(.[,-1:-2], use = "pairwise.complete.obs", method = "pearson"))) %>%
  bind_rows()

# For each matrix, adjust using the function above
env_cor_tp <- env_cor %>% 
  mutate(adj_cor_mat = list(corr_decomp(cor_mat)))

# Reconfigure the data and plot a heatmap
env_cor_tp_tidy <- env_cor_tp %>%
  split(.$trait) %>%
  map(group_by, trait) %>%
  map(function(trait_df) do(trait_df, {
    .$adj_cor_mat %>% as.data.frame() %>% rownames_to_column("env1") %>% gather(env2, correlation, -env1) }) ) %>%
  bind_rows()

env_cor_tp_tidy %>%
  ggplot(aes(x = env1, y = env2, fill = correlation)) +
  geom_tile() +
  scale_fill_gradientn(colors = c("blue", "white", "red"), na.value = "transparent", breaks = c(-1, 0, 1), limits = c(-1, 1), 
                       guide = guide_colorbar(title = "Genetic Correlation")) +
  ylab("Environment 2") +
  xlab("Environment 1") +
  facet_wrap(~ trait, nrow = 2, ncol = 2) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
    axis.text.y = element_text(size = 6)
  ) 


```


Calculate the genetic correlation between environments using the checks

```{r env.corr.chk}

# Calculate environmental correlations using all pairwise information on the checks
# First subset the data
pheno_use <- S2.MET.BLUE %>%
  filter(year != 2014)

# Extract tp and correlate
env_cor <- pheno_use %>% 
  filter(line_name %in% checks,
         !str_detect(trial, "S2C1F4")) %>%
  select(trait, line_name, environment, value) %>%
  # Split by trait
  split(.$trait) %>%
  map(spread, environment, value) %>%
  map(group_by, trait) %>%
  map(function(trait_mat) do(trait_mat, cor_mat = cor(.[,-1:-2], use = "pairwise.complete.obs", method = "pearson"))) %>%
  bind_rows()

# For each matrix, adjust using the function above
env_cor_chk <- env_cor %>% 
  mutate(adj_cor_mat = list(corr_decomp(cor_mat)))

# Reconfigure the data and plot a heatmap
env_cor_chk_tidy <- env_cor_chk %>%
  split(.$trait) %>%
  map(group_by, trait) %>%
  map(function(trait_df) do(trait_df, {
    .$adj_cor_mat %>% as.data.frame() %>% rownames_to_column("env1") %>% gather(env2, correlation, -env1) }) ) %>%
  bind_rows()

env_cor_chk_tidy %>%
  ggplot(aes(x = env1, y = env2, fill = correlation)) +
  geom_tile() +
  scale_fill_gradientn(colors = c("blue", "white", "red"), na.value = "transparent", breaks = c(-1, 0, 1), limits = c(-1, 1), 
                       guide = guide_colorbar(title = "Genetic Correlation")) +
  ylab("Environment 2") +
  xlab("Environment 1") +
  facet_wrap(~ trait, nrow = 2, ncol = 2) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
    axis.text.y = element_text(size = 6)
  ) 

```


Save the correlation matrices for further use

```{r}

save_file <- file.path(proj_dir, "Environmental_Variables/env_cov_mat_correlation.RData")
save("env_cor_tp", "env_cor_chk", file = save_file)


```

